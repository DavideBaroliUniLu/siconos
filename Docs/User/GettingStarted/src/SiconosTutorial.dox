/*! \page SiconosTutorial Siconos Tutorial (C++)

\section tutorialDiodeBridge Siconos Tutorial - A 4-diodes bridge wave rectifier

In this tutorial, we will describe the step-by-step building of a Non Smooth Dynamical System and its simulation, to represent the system on the figure below:

\image html diodeBridge.png
\image latex diodeBridge.eps "" width=10cm

In this sample, a LC oscillator initialized with a given voltage across the capacitor and a null current through the inductor provides the energy
to a load resistance through a full-wave rectifier consisting of a 4 ideal diodes bridge. Both waves of the oscillating voltage across the LC are provided to the resistor with current flowing always in the same direction. The energy is dissipated in the resistor resulting in a damped oscillation.

To run your own simulation using Siconos, you need to describe your system in a C++ file, let us call it diodeBridge.cpp. 
First of all, create wherever you want a new directory, say \e DiodeBridge, where you save as diodeBridge.cpp the template given \ref tutGCtemplate "here".

There are three main stages in the writing process:
-# the description of your Non Smooth Dynamical System
-# the description of the way it will be simulated (which discretization, which integrators, solvers ...)
-# the simulation loop writing.

Steps 1 and 2 lead to the building of a Model, which behavior is simulated in step 3.

\subsection tut1NSDS Building a NonSmoothDynamicalSystem

To build a NonSmoothDynamicalSystem, you need to clearly identify some DynamicalSystems and some Interactions, the last one being composed with Relations and Non Smooth Law. \n
In the present case, the oscillator is a time-invariant linear dynamical system, and using the Kirchhoff current and voltage laws and branch constitutive equations, its Dynamics is written as: 
\f[
\left[\begin{array}{c} 
\dot v_L\\
\dot i_L
\end{array}\right]=
\left[\begin{array}{cc} 
0 & \frac{-1}{C}\\
\frac{1}{L} & 0
\end{array}\right].
\left[\begin{array}{c} 
v_L\\
i_L
\end{array}\right]
+
\left[\begin{array}{cccc} 
0 & 0 & \frac{-1}{C} & \frac{1}{C}\\
0 & 0 & 0 & 0
\end{array}\right].
\left[\begin{array}{c} 
-v_{DR1}\\
-v_{DF2}\\
i_{DF1}\\
i_{DR2}
\end{array}\right]
\f]
and if we denote:
\f$ x = \left[\begin{array}{c} 
\dot v_L\\
\dot i_L
\end{array}\right]
\f$
,\f$ \lambda = \left[\begin{array}{c} 
-v_{DR1}\\
-v_{DF2}\\
i_{DF1}\\
i_{DR2}
\end{array}\right] \f$, \f$ A=\left[\begin{array}{cc} 
0 & \frac{-1}{C}\\
\frac{1}{L} & 0
\end{array}\right] \f$ and \f$ r= \left[\begin{array}{cccc} 
0 & 0 & \frac{-1}{C} & \frac{1}{C}\\
0 & 0 & 0 & 0
\end{array}\right].\lambda \f$,
it results in: 
\f[
\dot x = A.x + r
\f]
which fits with formalism proposed by \ref doc_ltids "LinearTIDS" class. 

Then in DiodeBridge.cpp, you can start the construction of your DynamicalSystem. First define the required parameters, matrices and vectors.

\code
// User-defined parameters
unsigned int ndof = 2;  // number of degrees of freedom of your system 
double Lvalue = 1e-2;   // inductance
double Cvalue = 1e-6;   // capacitance
double Rvalue = 1e3;    // resistance 

// DynamicalSystem(s)
SiconosMatrix * A = new SimpleMatrix(ndof,ndof); // All components of A are automatically set to 0.
(*A)(0,1) = -1.0/Cvalue;
(*A)(1,0) = 1.0/Lvalue;
\endcode
In the Doxygen documentation of class LinearTIDS, you can find a constructor with A, initial condition and a number that identify the system:
\code
// User-defined parameters
double Vinit = 10.0;    // initial voltage

// -- DynamicalSystem(s) --
// initial conditions vector
SiconosVector * x0 = new SimpleVector(ndof);
(*x0)(0) = Vinit;
// 
DynamicalSystem * oscillator = new LinearTIDS(1,*x0,*A);
\endcode

From this point you have access to all the methods of LinearTIDS for oscillator, like:

\code
oscillator->display(); 
oscillator->getNumber();
oscillator->getAPtr(); 
\endcode

Note that as arguments of the constructor, we gave *A or *x0, not A or x0; that means there is a copy of the values of A and x0 into new components, hold by
oscillator object.\n
To build A it is also possible to use an external file of data. See \ref matIO for details on that point.\n

As a last step, we save our DynamicalSystem into a new object called DynamicalSystemsSet, a set of systems as its name says. This sounds like nonsense since we have only one system, but that will be useful to handle our systems and pass them to the NonSmoothDynamicalSystem or the Interaction.

\code
DynamicalSystemsSet allDS; 
allDS.insert(oscillator);
\endcode

About sets handling, see \ref prelSTLTool. \n

You now need to describe some Interactions. \n
First, there are some linear relations between voltage and current inside the diode, given by:
\f[
\left[ \begin{array}{c}
i_{DR1}\\
i_{DF2}\\
-v_{DF1}\\
-v_{DR2}
\end{array} \right]
 = 
\left[ \begin{array}{cc}
0 & 0\\
0 & 0\\
-1 & 0\\
1 & 0
\end{array} \right]
 \cdot
\left[ \begin{array}{c}
v_L\\
i_L
\end{array} \right]
+
\left[ \begin{array}{cccc}
\frac{1}{R} & \frac{1}{R} & -1 & 0\\
\frac{1}{R} & \frac{1}{R} & 0 & -1\\
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0
\end{array} \right]
 \cdot
\left[ \begin{array}{c}
-v_{DR1}\\
-v_{DF2}\\
i_{DF1}\\
i_{DR2}
\end{array} \right] 
\f]
equivalent to \f$ y = Cx + D\lambda \f$, with \f$ y=\left[ \begin{array}{c}
i_{DR1}\\
i_{DF2}\\
-v_{DF1}\\
-v_{DR2}
\end{array} \right] \f$, \f$ C = \left[ \begin{array}{cccc}
\frac{1}{R} & \frac{1}{R} & -1 & 0\\
\frac{1}{R} & \frac{1}{R} & 0 & -1\\
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0
\end{array} \right] \f$ and \f$ D=\left[ \begin{array}{c}
-v_{DR1}\\
-v_{DF2}\\
i_{DF1}\\
i_{DR2}
\end{array} \right] \f$

Completed by the relation between r and \f$ \lambda \f$, this corresponds to a Siconos \ref docRelationLTI "LinearTIR". 

Looking into LinearTIR class doxygen documentation, you will a find constructor with matrices B and C and another one with B, C, D, e and F. Choose the first one, D will be set later. 

\code
// -- Interaction --
// - Relations - 
unsigned int ninter = 4; // dimension of your Interaction = size of y and lambda vectors
SiconosMatrix * B = new SimpleMatrix(ndof,ninter);
(*B)(0,2) = -1.0/Cvalue ; 
(*B)(0,3) = 1.0/Cvalue;
Siconos* C = new SimpleMatrix(ninter,ndof);
(*C)(2,0) = -1.0;
(*C)(3,0) = 1.0;

// the Relation:
LinearTIR * myRelation = new LinearTIR(*C,*B);
\endcode

If we stop here, all other potential components of the relation (D, F ...) are not build, that is to say they are equal to 0. 
So we need to build and set D. 

\code
SiconosMatrix* D = new SimpleMatrix(ninter,ninter);
(*D)(0,0) = 1.0/Rvalue;  (*D)(0,1) = 1.0/Rvalue; (*D)(0,2) = -1.0; 
(*D)(1,0) = 1.0/Rvalue;  (*D)(1,1) = 1.0/Rvalue; (*D)(1,3) = -1.0;  
(*D)(2,0) = 1.0; 
(*D)(3,1) = 1.0; 

myRelation->setDPtr(D); 
\endcode

Any member of a class has a corresponding setXXX (and getXXX) function you can use at any time. Moreover, when this member is a pointer, there is also
a setXXXPtr (or getXXXPtr) to work on the pointer, not on the object. The difference is important. Suppose in the case above that we use:

\code
myRelation->setD(*D); // warning: *D, we give the contains of the pointer as argument
\endcode

Then any change of D inside your main program will not affect the D matrix of myRelation, while with setDPtr(), since we pass the pointer, the matrix named D in your
program and the one of myRelation are the same object (and are in the same place in memory). This difference is important when you intend to save memory space.

OK, now you have a relation but to complete the Interaction, you need a non-smooth law. \n
On the figure below, the left-hand sketch displays the ideal diode characteristic and the right-hand sketch displays the usual exponential characteristic as stated by
Shockley's law.

\image html diodeNonSmooth.png

Thus the behavior of each diode of the bridge, supposed to be ideal, can be described with a complementarity condition between current and
reverse voltage (variables (\f$ y,\lambda \f$) ). Depending on the diode position in the bridge, y stands for the reverse voltage 
across the diode or for the diode current. \n
Then, the complementarity conditions, results of the ideal diodes characteristics are given by:\n

\f[ \begin{array}{l}
0 \leq -v_{DR1} \, \perp \, i_{DR1} \geq 0\\
0 \leq -v_{DF2} \, \perp \, i_{DF2} \geq 0\\
0 \leq i_{DF1} \, \perp \, -v_{DF1} \geq 0\\
0 \leq i_{DR2} \, \perp \, -v_{DR2} \geq 0
\end{array} \ \ \ \ \ \ or \ \ \ \ \ \  0 \leq y \, \perp \, \lambda \geq 0 \f]

You will then use a ComplementarityConditionNSL object for your non-smooth law:

\code
unsigned int nslawSize = 4; 
NonSmoothLaw * myNslaw = new ComplementarityConditionNSL(nslawSize);
\endcode

In that case, nslawSize is equivalent of the Interaction size. At this point you do not need to know more about that but if you need details on nslawSize meaning see \ref docNSL. 

You are now ready to build the Interaction. As usual, you will find the required constructor in the doxygen documentation of Interaction. As input, you need
the Relation and NonSmoothLaw pointers, a set of DynamicalSystems, the interaction size and some ids (a string and a number).\n

\code
// Choose a name and a number for your Interaction
string nameInter = "InterDiodeBridge"; 
unsigned int numInter = 1;
Interaction* myInteraction = new Interaction(nameInter,allDS,numInter,ninter, myNslaw, myRelation);
\endcode

All the objects required to build a NonSmoothDynamicalSystem are now available:

\code
NonSmoothDynamicalSystem* myNSDS = new NonSmoothDynamicalSystem(oscillator,myInteraction);
\endcode

This is the end of the first step: your system is now fully represented by the object myNSDS. Before dealing with the Simulation, first create the Model, 
the object that handles the NonSmoothDynamicalSystem and the Simulation. Building a Model is an easy thing: just give some time boundaries for the future simulation
and then associate your NonSmoothDynamicalSystem to the new Model. 

\code
// Model
double t0 = 0; // Initial time
double T = 10; // Total simulation time
Model * DiodeBridge = new Model(t0,T);
DiodeBridge->setNonSmoothDynamicalSystemPtr(myNSDS);
\endcode

\subsection tut1Simu The Simulation

You need now to define the way the behavior of you NonSmoothDynamicalSystem will be computed. That is the role of Simulation object.
Two different strategies are available at the time: TimeStepping or EventDriven. It's up to you to find the most adapted to your problem.
For details on both of them, see \ref docSimu. \n
Other important objects of the simulation that are to be defined are the time discretisation, some integrators for the Dynamics and a method to formalize and solve the non smooth problem. \n

For the Diode Bridge example, a TimeStepping strategy will be used, with a Moreau integrator and a LCP (Linear Complementarity Problem) formulation. 
First of all, it is necessary to create the Simulation object, and say "apply it to my non smooth system" which is done by associating the Simulation object with the Model:

\code
Simulation * s = new TimeStepping(DiodeBridge);
\endcode

Then you can create the TimeDiscretisation. There are different constructors, depending on what you want to fix: step size, number of time steps ...
Choose for example the one with the size of the time step. Since t0 and T are fixed in the Model, the time discretisation is then clearly defined. 

\code
double h =  1.0e-6;  // Time step
TimeDiscretisation * td = new TimeDiscretisation(h, s);
\endcode

Next, you have to define the a one-step integrator for all the DynamicalSystems. For TimeStepping scheme, the only available one is Moreau where the integration of the equations over the time steps is based on a \f$ \theta \f$ method (see \ref docSimuMoreauTS for details). 

\code
double theta = 0.5;
// One Step Integrator
Moreau* myIntegrator = new Moreau(oscillator,theta,s);
\endcode

After the integration of the Dynamics, the system is written as a Linear Complementarity Problem (see \ref docSimuLCP), and solved thanks to a solver algorithm of type NSQP (Non Smooth Quadratic Programming).

\code
// One Step non smooth problem
string solverName = "NLGS"; // non smooth problem solver algo name.
OneStepNSProblem* myLCP = new LCP(s, "LCP", solverName, 101, 0.0001, "max", 0.6 );
\endcode

Note that the simulation is always given as an input argument to the TimeDiscretisation, OneStepIntegrator and OneStepNSProblem constructors: all these objects are linked to one and only one simulation.  

The Model is now complete and the NonSmoothDynamicalSystem ready to be computed. This is the end of the second step.

\subsection tut1leadingSimu Leading the Simulation Process

From now on, you will work on the NonSmoothDynamicalSystem by calling some specific functions of the Simulation. \n
The first and compulsory step of any simulation process in Siconos is the initialization of the Simulation: 

\code
s->initialize();
\endcode

If something is wrong in your Model, that may be the point where error messages occur ...

Then the easiest way to run your simulation is to call

\code
s->run()
\endcode

But after that you only have access to values computed at the last time step, which might not be enough ...
So that may be better to write a complete time loop like:

\code
int k = td->getK(); // Current step 
int N = td->getNSteps(); // Number of time steps
while(k < N-1)	
{	
  s->nextStep();
  // get current time step
  k = td->getK();	
  s->computeOneStep();
}  
\endcode

nextStep is mainly used to increment the time step and say that last computed values will be initial values for the next step. \n
computeOneStep performs computation over the current time step. In the Moreau's time stepping case, it will first integrate the dynamics to obtain the
so-called free-state, that is without non-smooth effect, then it formalizes and solves a LCP before re-integrate the dynamics using the LCP results. 
(This is a quite simplified view of the Time Stepping process so for details check \ref docSimuMoreauTS). \n
The problem of output still remains. To answer that, we create a matrix where required output data will be save:

\code
// Before simulation loop
int k = td->getK(); // Current step 
int N = td->getNSteps(); // Number of time steps
unsigned int outputSize = 7; // number of required data
SimpleMatrix dataPlot(N,outputSize);
// We get values for the initial time step: 
// time
dataPlot(k, 0) = k*h;
// inductor voltage
dataPlot(k, 1) = (oscillator->getX())(0);
// inductor current
dataPlot(k, 2) = (oscillator->getX())(1);
// diode R1 current
dataPlot(k, 3) = (myInteraction->getY(0))(0);
// diode R1 voltage
dataPlot(k, 4) = -(myInteraction->getLambda(0))(0);
// diode F2 voltage 
dataPlot(k, 5) = -(myInteraction->getLambda(0))(1);
// diode F1 current
dataPlot(k, 6) = (myInteraction->getLambda(0))(2);

// Simulation loop
while(k < N-1)	
{	
  s->nextStep();
  // get current time step
  k = td->getK();	
  s->computeOneStep();
  dataPlot(k, 0) = k*h;
  dataPlot(k, 1) = (oscillator->getX())(0);
  dataPlot(k, 2) = (oscillator->getX())(1);
  dataPlot(k, 3) = (myInteraction->getY(0))(0);
  dataPlot(k, 4) = -(myInteraction->getLambda(0))(0);
  dataPlot(k, 5) = -(myInteraction->getLambda(0))(1);
  dataPlot(k, 6) = (myInteraction->getLambda(0))(2);
}  

// Write the results into the file "DiodeBridge.dat"
ioMatrix io("DiodeBridge.dat", "ascii");
io.write(dataPlot);
\endcode

Do not forget to release memory for pointers at the end:

\code
delete A;
delete x0;
delete oscillator;
delete B;
delete myRelation;
delete D;
delete myNslaw;
delete myRelation;
delete myNSDS;
delete DiodeBridge;
delete s;
delete td;
delete myIntegrator;
delete myLCP;
\endcode

To complete DiodeBridge.cpp, some header files are required:

\code
// Header files
#include "Model.h"
#include "LinearTIDS.h"
#include "LinearTIR.h"
#include "ComplementarityConditionNSL.h"
#include "TimeStepping.h"
#include "ioMatrix.h"
#include <string>
#include <iostream>
\endcode

The full cpp file is available \ref tutorialSample1 "here"

\subsection tutDiodeResults Results
You can now run in a terminal:

\verbatim
siconos DiodeBridge.cpp
\endverbatim

Results are given on the figure below:

\image html diodeBridgeResult.png

\section tutorialMultiBalls Siconos Tutorial - A columns of three beads

As described in the figure below, we consider a ball of mass m and radius R, described by 3 generalized coordinates \f$ q=(z,x,\theta) \f$. The ball is subjected to the gravity g and a vertical external force f(t). The system is also constituted by a rigid plane, defined by its position h with respect to the axis Oz. We assume that the position of the plane is fixed.  \n

\image html bouncingBall.png.

\subsection tutMultiBallNSDS Building the Non-Smooth Dynamical System

The equation of motion of the ball is given by: \n
\f[ M\ddot q = F_{ext}(t) + p \ \ with \ \ M=\left[\begin{array}{ccc}
  m &0 &0 \\
  0 & m & 0 \\
  0 & 0 & I
  \end{array}\right] \ \ , \ \ I = \frac{3}{5}mR^2 \ \ and \ \ F_{ext} = \left[\begin{array}{c}
  -m g \\
  0  \\
  0
  \end{array}\right] \f]
For this tutorial, we will suppose now that we have a column of "dsNumber" balls like the one above (mass and radius may be different, and if necessary, variables will be indexed by i, i being the number of the ball). Each ball is governed by a linear system like the one written for a single ball and may be in contact with the balls above and below it.
- \f$ Q(q,\dot q ): \b R^n  X \b R^n \mapsto \mathcal \b R^{n}\f$  is the non linear inertia term,
- \f$ F(\dot q, q , t) : \b R^n  X \b R^n  X \b R \mapsto \mathcal \b R^{n}\f$  is the internal force of the system,
- \f$ F_{ext}(t):  \b R \mapsto \mathcal \b R^{n}  \f$   is the given external force,

Let us now start the writing of the input file. Like for the first tutorial, we create a new directory, multiBeads, and save the template given \ref tutGCtemplate "here" as multiBeads.cpp. 

We start by setting some parameters, like the number of balls, their initial positions and velocities and so on. 
\code 
// User-defined main parameters 
unsigned int dsNumber = 10;     // the number of dynamical systems 
unsigned int nDof = 3;           // degrees of freedom for beads
double increment_position = 1;   // initial position increment from one DS to the following
double increment_velocity = 0;   // initial velocity increment from one DS to the following
double t0 = 0;                   // initial computation time
double T = 10;                   // final computation time 
double h = 0.005;                // time step
double position_init = 10.5;        // initial position for lowest bead.
double velocity_init = 0.0;      // initial velocity for lowest bead.
double R = 0.1;                  // balls radius
\endcode

Then, we define some initial conditions for the balls, and create the corresponding Dynamical Systems, all of type Lagrangian, Linear and Time Invariant. 
All the systems are inserted in a container, a DynamicalSystemsSet, named allDS. \n
From now on, to simplify writing, we suppose that all balls have the same mass, m = 1,  and the same radius, R=0.1. 

\code
// -------------------------
// --- Dynamical systems --- 
// -------------------------

    unsigned int i;
    // A set of DS that will handle all the "balls"
    DynamicalSystemsSet allDS; 
    // mass matrix, set to identity
    SiconosMatrix *Mass = new SimpleMatrix(nDof,nDof);
    Mass->eye();
    (*Mass)(2,2) = 3/5*R*R;

    // -- Initial positions and velocities --
    // q0[i] and v0[i] correspond to position and velocity of ball i. 
    vector<SimpleVector *> q0;
    vector<SimpleVector *> v0;
    q0.resize(dsNumber,NULL);
    v0.resize(dsNumber,NULL);

    for (i=0;i<dsNumber;i++)
      {
        // Memory allocation for q0[i] and v0[i]
	q0[i] = new SimpleVector(nDof);
	velocity0[i] = new SimpleVector(nDof); 
        // set values
	(*(q0[i]))(0) = position_init;
	(*(velocity0[i]))(0) = velocity_init;
        // Create a new Lagrangian Linear Dynamical System, with q0] and v0[i] as initial conditions,
        // Mass as mass matrix and i as number of identification. 
        // The system is then inserted in allDS. 
	allDS.insert( new LagrangianLinearTIDS(i,nDof,*(q0[i]),*(velocity0[i]),*Mass));
	// Increment values for next system
	position_init+= increment_position;
	velocity_init+= increment_velocity;
      }
\endcode

Next, it is necessary to define the external forces, the gravity, applied on each ball. According to \ref doc_dsPlugin, a plug-in function is available for those forces. (For details on plug-in functions, see \ref doc_usingPlugin). Its signature (the type of its arguments) is given in DefaultPlugin.cpp. So we copy it in a new file, say BeadsPlugin.cpp, and we define an extern function, fExt. \n

\code
const double m = 1; // bead mass
const double g = 9.81; // gravity
extern "C" void fExt(unsigned int sizeOfq, double time,	double * fExt, double *param)
{
  // set fExt components to 0
  for (unsigned int i = 0; i < sizeOfq; i++)
    fExt[i] = 0.0;
  // apply gravity
  fExt[0] = -m*g;
} 
\endcode
\b Warning: 
- fExt must be an " extern "C" " function, and code is C, not C++. 
- the name of the plugin file, BeadsPlugin.cpp here, must be xxxPlugin.cpp, xxx being whatever you want. 


Now we have to say "use fExt from BeadsPlugin.cpp to compute the external forces of my systems". \n
This is done thanks to "setComputeFExtFunction" function:

\code
   // 	
   CheckInsertDS checkDS; 
   for (i=0;i<dsNumber;i++)
      {
	... 
        // Create and insert in allDS a new Lagrangian Linear Dynamical System ...
	checkDS = allDS.insert( new LagrangianLinearTIDS(i,nDof,*(q0[i]),*(velocity0[i]),*Mass));
        // Note that we now use a CheckInsertDS object: checkDS.first is 
	// an iterator that points to the DS inserted above.
        // 
	// Set the external forces for the last created system. 
	(static_cast<LagrangianDS*>(*(checkDS.first)))->setComputeFExtFunction("BeadsPlugin.so", "fExt");
	// A cast is required, since allDS handles DynamicalSystem*, not LagrangianLinearTIDS*. 
	...
      }
\endcode

From this point, any call to the external forces of a system in allDS will result in a call to the function fExt defined in BeadsPlugin.cpp.\n
\b Remark: m and R are set inside the BeadsPlugin file but it would also be possible, and maybe better, to pass them as parameters in fExt function. 
See \ref doc_usingPlugin for details on that option. \n

Ok, now DynamicalSystems are clearly defined and all saved in allDS. Let's turn our attention to Interactions. In the same way, they will be handled by a container, an InteractionsSet, named allInteractions. For dsNumbers systems, there are dsNumbers-1 "bead-bead" Interactions plus one between the "bottom bead" and the floor. \n

We start with bead-floor Interaction: the ball at the bottom bounces on the rigid plane, introducing a constraint on the position of the ball, given by:
\f[ z-R-h\geq 0 \f]
Thus, as a local variables of the Interaction, we introduce y as the distance between the ball and the floor and \f$ \lambda \f$ as the multiplier that corresponds to 
the reaction at contact. 
Then, 
\f{eqnarray*}
y = Hq + b = [1 \ 0 \ 0] q - R - h  \\
and \\
p = H^t \lambda 
\f}
(next, we set h=0). \n
Thus, at impact the unilateral constraint is such that:
\f[ 0 \leq y \perp \lambda \geq 0 \f]
completed with a Newton Impact law, for which we set the restitutive coefficient e to 0.9: 
\f[ if \ y=0, \ \dot y(t^+) = -e \dot y(t^-) \f] 
\f$ t^+ \f$  and \f$ t^- \f$ being post and pre-impact times. 
The first Interaction can then be constructed:

\code
// -------------------
// --- Interactions---
// -------------------
InteractionsSet allInteractions;
// The total number of Interactions
int interactionNumber = dsNumber;

// Interaction first bead and floor
// A set for the systems handles by the "current" Interaction
DynamicalSystemsSet dsConcerned;
// Only the "bottom" bead is concerned by this first Interaction, therefore DynamicalSystem number 0.
dsConcerned.insert(allDS.getDynamicalSystemPtr(0)); 
// -- Newton impact law -- 
double e = 0.9;
NonSmoothLaw * nslaw0 = new NewtonImpactNSL(e);
// Lagrangian Relation
unsigned int interactionSize = 1; // y vector size
SiconosMatrix *H = new SimpleMatrix(interactionSize,nDof);
(*H)(0,0) = 1.0;
SiconosVector *b = new SimpleVector(interactionSize);
(*b)(0) = -R;
Relation * relation0 = new LagrangianLinearR(*H,*b);
// Interaction
unsigned int num = 0 ; // an id number for the Interaction
Interaction * inter0 = new Interaction("floor", dsConcerned,num,interactionSize, nslaw0, relation0);
allInteractions.insert(inter0);
\endcode

In the same way, the potential contact between two balls introduces some new constraints: \n
\f$ (z_i-R_i)-(z_j-R_j)-h \geq 0 \f$, if ball i is on top of ball j. \n

So if we consider the Interaction between ball i and j, y being the distance between two balls and \f$ \lambda \f$ the multiplier, we get: \n
\f{eqnarray*}
y = HQ + b = [-1 \ 0 \ 0 \ 1 \ 0 \ 0]Q + R_j-R_i-h \\
p = H^t \lambda \\
\f}
with 
\f[
Q = \left[\begin{array}{c}
q_j \\
q_i
\end{array}\right]
\f]

With the same non smooth law as for the first Interaction. 
\code
// A list of names for the Interactions
vector<string> id;
id.resize(interactionNumber-1);

CheckInsertInteraction checkInter;

// A vector that will handle all the relations
vector<Relation*> LLR(interactionNumber-2);

// 
SiconosMatrix *H1 = new SimpleMatrix(1,2*nDof);

if (dsNumber>1)
{
 (*H1)(0,0) = -1.0;
 (*H1)(0,3) = 1.0;
 // Since Ri=Rj and h=0, we do not need to set b.
 Relation * relation = new LagrangianLinearR(*H1);
 for (i=1;(int)i<interactionNumber-1;i++)
  {
   // The systems handled by the current Interaction ...
   dsConcerned1.clear();
   dsConcerned.insert(allDS.getDynamicalSystemPtr(i-1));
   dsConcerned.insert(allDS.getDynamicalSystemPtr(i));
   // The id: "i"
   ostringstream ostr;
   ostr << i;
   id[i-1]= ostr.str();
   // The relations
   LLR[i-1] = new LagrangianLinearR(*relation); // we use copy constructor to built all relations
   checkInter = allInteractions.insert( new Interaction(id[i-1], dsConcerned1,i,interactionSize, nslaw0, LLR[i-1]));
  }
delete relation;
}
\endcode

Note that each Relation corresponds to one and only one Interaction (which is not the case of NonSmoothLaw); that's why we need to built a new Relation LLR[i-1] for each Interaction. 

Everything is now ready to build the NonSmoothDynamicalSystem and the related Model:

\code
    // --------------------------------
    // --- NonSmoothDynamicalSystem --- 
    // --------------------------------
    NonSmoothDynamicalSystem * nsds = new NonSmoothDynamicalSystem(allDS, allInteractions);
    
    // -------------
    // --- Model ---
    // -------------

    Model * multiBeads = new Model(t0,T); 
    multiBeads->setNonSmoothDynamicalSystemPtr(nsds); // set NonSmoothDynamicalSystem of this model
\endcode

\subsection tutMultiBallSimu The Simulation

\subsubsection tutMultiBallSimuTS Time-Stepping scheme

As a first example, we will use a Moreau's time-stepping scheme, where the non-smooth problem will be written as a LCP. The process is more or less the same as for the Diode Bridge case, so we won't detail it. The only difference is that now, the OneStepIntegrator handles several DynamicalSystems. 

\code
    string solverName = "Lemke";      // solver algorithm used for non-smooth problem
    double h = 0.005;                // time step
    Simulation* s = new TimeStepping(multiBeads);

    // -- Time discretisation --
    TimeDiscretisation * t = new TimeDiscretisation(h,s);

    // -- OneStepIntegrators --
    double theta = 0.5000001; 
    OneStepIntegrator * OSI = new Moreau(allDS , theta ,s);
    // That means that all systems in allDS have the same theta value.	

    // -- OneStepNsProblem --
    OneStepNSProblem * osnspb = new LCP(s,"LCP",solverName,10001, 0.001);
\endcode

\subsubsection tutMultiBallSimuED Event-Driven algorithm

In that second part, an event-driven algorithm is used to solve the problem. Event-Driven Simulation principle is detailed in \ref docSimuED. \n
The dynamics is decomposed in "modes", time-intervalls where the dynamics is smooth and discrete events where the dynamics is non-smooth. \n
In the present case, non smooth events will corresponds to impacts between balls. Each time such an event is detected, a non-smooth problem is formalized and solved (as a LCP here) while between events, the systems are integrated thanks to Lsodar, ODE solver with roots-finding algorithm. \n

As for the Time-stepping, we first need to built the simulation and then its time-discretisation:

\code

// The simulation belongs to Model multiBeads
EventDriven* s = new EventDriven(multiBeads); 
TimeDiscretisation * t = new TimeDiscretisation(h,s);
\endcode

Next step is the declaration of integrators for the dynamical systems.
The integrator will handle all the DynamicalSystems of the Model. During integration of the systems, Lsodar will search for roots of some equations (the constraints ie the Interactions of the NonSmoothDynamicalSystem). The required OSI type is Lsodar, applied to allDS:

\code
OneStepIntegrator * OSI = new Lsodar(allDS,s); 
\endcode

Each time a root is found, a new NonSmoothEvent is created and it's then necessary to write and solve a non-smooth problem. We won't detail this here but just remember that this requires two LCP, one at "velocity" level, named impact, and another at "acceleration" level, named acceleration. 
The whole event-driven algorithm for Lagrangian Systems is available here: docSimuEDDetails. 

\code
OneStepNSProblem * impact = new LCP(s, "impact",solverName,101, 0.0001,"max",0.6);
OneStepNSProblem * acceleration = new LCP(s, "acceleration",solverName,101, 0.0001,"max",0.6);
\endcode

The Model is now complete, we can start the simulation process.

\subsection tutMultiBallsRun Simulation Process

\subsubsection tutMultiBallsRunTS Time-Stepping

Once again, the process is the same as in the first tutorial and won't be detailed. \n
Concerning the output, we save the position and velocity of all balls.

\code
s->initialize(); 

int k = t->getK(); // Current step 
int N = t->getNSteps(); // Number of time steps

// Prepare output and save value for the initial time
unsigned int outputSize = dsNumber*2+1;
SimpleMatrix dataPlot(N+1,outputSize ); // Output data matrix
// time
dataPlot(k, 0) = k*t->getH();
// Positions and velocities
i = 0; // Remember that DS are sorted in a growing order according to their number.
DSIterator it;
for(it = allDS.begin();it!=allDS.end();++it)
  {
    dataPlot(k,(int)i*2+1) = static_cast<LagrangianLinearTIDS*>(*it)->getQ()(0);
    dataPlot(k,(int)i*2+2) = static_cast<LagrangianLinearTIDS*>(*it)->getVelocity()(0);
    i++;
  }
\endcode
Note that we use a "DSIterator", which is no more than a pointer on a set of DynamicalSystems; allDS.begin() is a pointer on the first object handled by allDS and allDS.end() a pointer "just after" the last object handled by allDS. The current pointed system is then *it ("content of the pointer"). Thus, in the loop above, we sweep through all the DynamicalSystems and get the corresponding q and v. \n
A static_cast is also required since allDS contains DynamicalSystem whereas we need functions specific to LagrangianDS (getQ ...). 

Next, we write:
\code
while(k < N)	
 {
  s->nextStep();
  // get current time step
  k = t->getK();
  // solve ... 
  s->computeOneStep();
  dataPlot(k, 0) = k*t->getH();
  // 
  i = 0;
  for(it = allDS.begin();it!=allDS.end();++it)
   {
    dataPlot(k,(int)i*2+1) = static_cast<LagrangianLinearTIDS*>(*it)->getQ()(0);
    dataPlot(k,(int)i*2+2) = static_cast<LagrangianLinearTIDS*>(*it)->getVelocity()(0);
    i++;
  }
\endcode

and for output file saving:

\code
ioMatrix io("result.dat", "ascii");
io.write(dataPlot,"noDim");
\endcode

\subsubsection tutMultiBallRunED Event-Driven


*/

/*! \page tutorialSample1 DiodeBridge.cpp
\code
// Header files
#include "Model.h"
#include "LinearTIDS.h"
#include "LinearTIR.h"
#include "ComplementarityConditionNSL.h"
#include "TimeStepping.h"
#include "ioMatrix.h"
#include <string>
#include <iostream>

using namespace std;

// main program
int main(int argc, char* argv[])
{
  // Exception handling
  try{
    // == User-defined parameters ==
    unsigned int ndof = 2;  // number of degrees of freedom of your system 
    double Lvalue = 1e-2;   // inductance
    double Cvalue = 1e-6;   // capacitance
    double Rvalue = 1e3;    // resistance 
    double Vinit = 10.0;    // initial voltage
    double t0 = 0.0;
    double T = 5e-3;        // Total simulation time
    double h = 1.0e-6;      // Time step
    string solverName = "NSQP"; // non smooth problem solver algo name.
	
    // ================= Creation of the model =======================

    // == Creation of the NonSmoothDynamicalSystem ==
    // DynamicalSystem(s)
    SiconosMatrix * A = new SimpleMatrix(ndof,ndof); // All components of A are automatically set to 0.
    (*A)(0,1) = -1.0/Cvalue;
    (*A)(1,0) = 1.0/Lvalue;
    SiconosVector * x0 = new SimpleVector(ndof);
    (*x0)(0) = Vinit;
    DynamicalSystem * oscillator = new LinearTIDS(1,*x0,*A);
    DynamicalSystemsSet allDS; 
    allDS.insert(oscillator);
    // Relations
    unsigned int ninter = 4; // dimension of your Interaction = size of y and lambda vectors
    SiconosMatrix * B = new SimpleMatrix(ndof,ninter);
    (*B)(0,2) = -1.0/Cvalue ; 
    (*B)(0,3) = 1.0/Cvalue;
    SiconosMatrix * C = new SimpleMatrix(ninter,ndof);
    (*C)(2,0) = -1.0;
    (*C)(3,0) = 1.0;
    LinearTIR * myRelation = new LinearTIR(*C,*B);
    SiconosMatrix* D = new SimpleMatrix(ninter,ninter);
    (*D)(0,0) = 1.0/Rvalue;  (*D)(0,1) = 1.0/Rvalue; (*D)(0,2) = -1.0; 
    (*D)(1,0) = 1.0/Rvalue;  (*D)(1,1) = 1.0/Rvalue; (*D)(1,3) = -1.0;  
    (*D)(2,0) = 1.0; 
    (*D)(3,1) = 1.0; 
    myRelation->setDPtr(D); 

    // NonSmoothLaw
    unsigned int nslawSize = 4; 
    NonSmoothLaw * myNslaw = new ComplementarityConditionNSL(nslawSize);

    // Choose a name and a number for your Interaction
    string nameInter = "InterDiodeBridge"; 
    unsigned int numInter = 1;
    Interaction* myInteraction = new Interaction(nameInter,allDS,numInter,ninter, myNslaw, myRelation);
    // NonSmoothDynamicalSystem	
    NonSmoothDynamicalSystem* myNSDS = new NonSmoothDynamicalSystem(oscillator,myInteraction);
    // Model
    Model * DiodeBridge = new Model(t0,T);
    DiodeBridge->setNonSmoothDynamicalSystemPtr(myNSDS);
    // == Creation of the Simulation ==
    Simulation * s = new TimeStepping(DiodeBridge);
    // TimeDiscretisation
    TimeDiscretisation * td = new TimeDiscretisation(h, s);
    // OneStepIntegrator
    double theta = 0.5;
    // One Step Integrator
    Moreau* myIntegrator = new Moreau(oscillator,theta,s);
    // OneStepNSProblem
    // One Step non smooth problem
    OneStepNSProblem* myLCP = new LCP(s, "LCP", solverName, 101, 0.0001, "max", 0.6 );
    // ================================= Computation =================================

    // --- Initialisation of the simulation ---
    s->initialize();    
    
    int k = td->getK(); // Current step 
    int N = td->getNSteps(); // Number of time steps
    unsigned int outputSize = 7; // number of required data
    SimpleMatrix dataPlot(N,outputSize);
    // We get values for the initial time step: 
    // time
    dataPlot(k, 0) = k*h;
    // inductor voltage
    dataPlot(k, 1) = (oscillator->getX())(0);
    // inductor current
    dataPlot(k, 2) = (oscillator->getX())(1);
    // diode R1 current
    dataPlot(k, 3) = (myInteraction->getY(0))(0);
    // diode R1 voltage
    dataPlot(k, 4) = -(myInteraction->getLambda(0))(0);
    // diode F2 voltage 
    dataPlot(k, 5) = -(myInteraction->getLambda(0))(1);
    // diode F1 current
    dataPlot(k, 6) = (myInteraction->getLambda(0))(2);

    // Simulation loop
    while(k < N-1)	
      {	
	s->nextStep();
  	// get current time step
	k = td->getK();	
	s->computeOneStep();
 	dataPlot(k, 0) = k*h;
	dataPlot(k, 1) = (oscillator->getX())(0);
	dataPlot(k, 2) = (oscillator->getX())(1);
	dataPlot(k, 3) = (myInteraction->getY(0))(0);
	dataPlot(k, 4) = -(myInteraction->getLambda(0))(0);
	dataPlot(k, 5) = -(myInteraction->getLambda(0))(1);
	dataPlot(k, 6) = (myInteraction->getLambda(0))(2);
      }  

    // Write the results into the file "DiodeBridge.dat"
    ioMatrix io("DiodeBridge.dat", "ascii");
    io.write(dataPlot);

    // --- Time loop ---
    
    // --- Free memory --- 
    delete myLCP;
    delete myIntegrator;
    delete td;
    delete s;
    delete DiodeBridge;
    delete myNSDS;
    delete myRelation;
    delete myNslaw;
    delete myInteraction;
    delete B;
    delete D;
    delete oscillator;
    delete x0;
    delete A;
  }
	
  catch(SiconosException e)
    {cout << e.report() << endl;}
  catch(...)
    {cout << "Exception caught in DiodeBridge.cpp" << endl;}
}
\endcode
*/
