<!DOCTYPE html PUBLIC "-//Tigris//DTD XHTML 1.0 Transitional//EN" "http://style.tigris.org/tigris_transitional.dtd">
<html>
<head>
  <style type="text/css">
/* <![CDATA[ */ 
@import "css/readyset.css"; 
@import "css/inst.css";
/*  ]]> */
 </style>
  <link rel="stylesheet" type="text/css" href="css/print.css"
 media="print">
  <title>QA Plan</title>
</head>
<body>
<div class="app">
<div class="readyset">
<h1>Quality Assurance Plan</h1>
<div id="releaseinfo">
<h2>Release Information</h2>
<table class="axial" border="1" cellpadding="3" cellspacing="2">
  <tbody>
    <tr>
      <th>Project</th>
      <td><a href="index.html">Siconos</a></td>
    </tr>
    <tr>
      <th>Internal Release Number:</th>
      <td>0.0<br>
      </td>
    </tr>
    <tr>
      <th>Attached Worksheets:</th>
      <td>
      <div>QA plan &gt; Quality Report<br>
      </div>
      </td>
    </tr>
    <tr>
      <th>Related Documents:</th>
      <td>
      <div><a href="srs.html">Software Requirements Specification</a></div>
      <div><a href="design.html">Design</a></div>
      <div><a href="sdm.html">Software development methodology</a></div>
      <div>ESA software engineering standards<br>
      </div>
      </td>
    </tr>
  </tbody>
</table>
</div>
<!-- /releaseinfo -->
<div id="processimpact"> <strong>Process impact:</strong> This
document specifies quality goals, selects strategies for assuring that
those goals have been met, and details a plan of action to carry out
those strategies. </div>
<!-- /processimpact -->
<div id="introduction">
<h2>Introduction</h2>
<br>
The purpose of the quality assurance plan is to check that the project
is
consistent with standards and plans which are defined below. As it is
recommended by the ESA software engineering standards to
small software projects, the Quality Plan combines the following
documents for small projects :
<ul>
  <li>The software Project Management Plan. </li>
  <li>The software Configuration Management Plan. </li>
  <li>The software Verification and Validation Plan.</li>
</ul>
References<br>
<ul>
  <li>"Guide to applying the ESA software engineering standards to
small software projects. ", BSSC(96)2, esa 1996, </li>
  <li>"Guide to the software project management ", PSS-05-08, esa 1995,
  </li>
  <li>"Guide to the software configuration management", PSS-05-09, esa
1995, </li>
  <li>"Guide to the software verification and validation", PSS-05-10,
esa 1995, </li>
  <li>"Guide to the software quality assurance", PSS-05-11, esa 1995,</li>
</ul>
<br>
<p>
</p>
<h2>Project Management Plan</h2>
<h3>Introduction</h3>
Software project management is 'the process of planning,
organizing,
staffing, monitoring, controlling and leading a software project'. This
part is based on the ESA ``guide to the software project management'',
PSS-05-08, esa 1995.<br>
<br>
This part defines the project management plan of the siconos platform.
The project organization&nbsp; and the major features of the technical
process are defined. Finally, a work breakdown structure, a schedule
with milestones and the roles and responsibilities are provided.
<p>Actually, only the project management plan, and the technical
process for&nbsp; Siconos/Kernel and Siconos/Numerics are detailed.
</p>
<p>For the more elaborate part of the platform, which are
Siconos/Analysis, Siconos/Control and Siconos/IMSE, separated documents
will be provided.
<br>
</p>
<h3><a name="Project_Organisation"></a>Project Organization<br>
</h3>
<h4>Organizational roles and responsibilities<br>
</h4>
<br>
<p>Due to the number of participants in the software project
development,
the organization of the project is relatively simple. The Work Package
2 (Numerical Methods and Software development) is led by Vincent ACARY
(C01), which is also the project manager of the software design and
development. <br>
</p>
<p>The teams for the design and the development are defined as follows
:
</p>
<ol>
  <li>Team INRIA (C01):
    <dl compact="compact">
    </dl>
    <ul>
      <li>Vincent Acary (VA) (Team
Leader, designer, programmer) Vincent.Acary@inrialpes.fr </li>
      <li>Roger Pissard-Gibollet (RPG)
(Software quality leader) </li>
      <li>Franck
P&eacute;rignon (FP) (programmer, test engineer , numerical algorithms)</li>
    </ul>
    <dl compact="compact">
    </dl>
Former members:</li>
  <ul>
    <li>Jean-Baptiste Charlety (JBC) (programmer, test engineer ,
software librarian) (01/2004 to 04/2005)</li>
    <li>Jean-Michel Barbier (JMB) (programmer, test engineer,
software librarian) (01/2004 to 09/2004)</li>
  </ul>
  <li>Team LMGC (AC2): <br>
    <dl compact="compact">
    </dl>
    <ul>
      <li>Fr&eacute;d&eacute;ric Dubois (FD) (Team Leader, designer,
programmer) </li>
      <li>Sh&eacute;herazade Nineb (SN) (programmer)</li>
    </ul>
Former members:</li>
  <ul>
    <li>Jean-Michel Barbier (JMB) (programmer, test engineer,
software librarian)(10/2004 to 04/2005)</li>
  </ul>
  <li>Team Analysis (CR6,CR4,CR9,AC5,CR7,AC12,CR8),</li>
</ol>
<ul>
  <li>Key Developpers</li>
  <ul>
    <li>Gustavo Osorio (GA) gosorio@unina.it</li>
    <li>Ivan Merillas (IM) merillas@mat.upc.edu</li>
    <li>Petri Piiroinen (PP) petri.piiroinen@bristol.ac.uk</li>
  </ul>
  <li>Developpers</li>
  <ul>
    <li>Fabiola angulo (FA) fangulo@nevado.manizales.unal.edu.co </li>
    <li>Alan Champneys (AR) a.r.champneys@bristol.ac.uk</li>
    <li>Enric Fossas (EF) enric.fossas@upc.edu <br>
    </li>
    <li>Gino Ianelli (GI) luigi.iannelli@unisannio.it</li>
    <li>Arne Nordmark (AN) nordmark@mech.kth.se</li>
    <li>Gerard Olivar (GO) gerard@mat.upc.edu</li>
  </ul>
  <li>Testing Team</li>
  <ul>
    <li>Mario Di Bernardo (MdB) m.dibernardo@bristol.ac.uk</li>
    <li>Kanat Camlibel (KC) k.camlibel@uvt.nl</li>
    <li>Ugo Galvenetto (UG) u.galvanetto@imperial.ac.uk</li>
    <li>Stefania Santini (SS) stsantini@unina.it</li>
    <li>David Wagg (DW) david.wagg@bristol.ac.uk</li>
    <li>Nathan van der Vouw (NW) n.v.d.wouw@tue.nl </li>
  </ul>
</ul>
<ul>
  <li>Team "Control", tbd </li>
  <li>Team imse, tbd </li>
</ul>
<ul>
  <ul>
  </ul>
</ul>
<p>
The roles and responsibilities are roughly distributed in the
table&nbsp;<a href="../QP/QP/QP.html#Tab:Role1">2.1</a>.&nbsp;
</p>
<p><br>
</p>
<div align="center"><a name="351"></a>
<table>
  <caption><strong>Table 2.1:</strong>
Roles and responsibilities</caption> <tbody>
    <tr>
      <td>
      <div align="center">
      <table border="1" cellpadding="3">
        <tbody>
          <tr>
            <td align="left">Role</td>
            <td align="left">Teams</td>
          </tr>
          <tr>
            <td align="left">Siconos/Numerics</td>
            <td align="left">Team LMGC, Team INRIA</td>
          </tr>
          <tr>
            <td align="left">Siconos/Kernel</td>
            <td align="left">Team INRIA, Team LMGC</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">Siconos/Front-End<br>
            </td>
            <td style="vertical-align: top;">Team INRIA<br>
            </td>
          </tr>
          <tr>
            <td align="left">Siconos/Analysis</td>
            <td align="left">Team Bristol</td>
          </tr>
          <tr>
            <td align="left">Siconos/Control</td>
            <td align="left">Team Control</td>
          </tr>
        </tbody>
      </table>
      <a name="Tab:Role1"></a></div>
      </td>
    </tr>
  </tbody>
</table>
</div>
<br>
<p>
</p>
<br>
<h4>Organisational interfaces.</h4>
<br>
<p>The initiators of the project are the members of the Work Package 2.
The end users of the platform are the whole community of SICONOS, at
least, for the first release. Then further distributions of the
software will take into account the requirements of a wider scientific
community, and then, of the industrial partners.
</p>
<p>The interfaces between the Work Package 2 and the community of users
is under the responsibility of the project manager.
</p>
<br>
<h3>Technical Process for the Siconos/Platform</h3>
<br>
<p>The section below focuses only on the technical process for the
Siconos/Numerics and the Siconos/Kernel of the platform. It should be
extended for the
analysis, control and the imse.
</p>
<h4><a name="SECTION00331000000000000000">Process model</a></h4>
<h5><a name="SECTION00331100000000000000">Definitions of the phases of
the design and the development </a></h5>
<h5>
</h5>
<p>Following the ESA standards for small projects ESA-PSS050, the
following phases of the design and the development are defined :
</p>
<ul>
  <li><b>The UR/SR phase</b>. The UR phase is the ``problem definition
phase'' of a software project. The scope of the system must be defined.
The user requirements must be captured. The SR phase is the
``analysis'' phase of a software project. A vital part of the analysis
activity is the construction of a ``model'' describing <i>what</i> the
software has to do, and not <i>how</i>
to do it. Building prototypes to clarify the software requirements may
be necessary. The principal deliverables of this phase are the User
requirements Document (URD) and the Software Requirements document
(SRD). </li>
  <li><b>The AD phase</b>.The purpose of the AD phase is to define the
structure of the software. The model constructed in the SR phase is the
starting point.This model is transformed into the architectural design
by allocating functions to software components and defining the control
and data flow between them. The deliverable item which constitutes the
formal output of this phase is the Architectural Design Document (ADD).
  </li>
  <li><b>The DD Phase</b> The purpose of the DD phase is to detail the
design of the software, and to code, document and test it. The Detailed
Design Document (DDD) and the Software User Manual (SUM) are produced
concurrently with coding and testing. </li>
  <li><b>The TR Phase</b> The purpose of this phase is to establish
that
the software fulfills the requirements laid down in the SRD. This is
done by installing the software and conducting acceptance tests. </li>
  <li><b>The OM Phase</b> Once the software has entered into operation,
it should be carefully monitored to confirm that it meets all the
requirements defined in the SRD. Some of the requirements, for example
those for availability, may take a period of time to validate. When the
software has passed all the acceptance tests, it can be finally
accepted. This is the OM Phase. </li>
</ul>
<h5><a name="SECTION00331200000000000000">
Project planning inputs and outputs</a></h5>
<p>
The inputs to software project planning are: </p>
<ul>
  <li>User requirements&nbsp; </li>
  <li> <a href="srs.html">Software requirements specification</a>&nbsp;
and <a href="design.html">design</a> documents according to each phases<br>
  </li>
  <li>ESA software standards for products and procedures; </li>
  <li>time constraints, such as delivery dates; </li>
  <li>resource constraints, such as the availability of staff; </li>
</ul>
<p>
The outputs to software project planning are:
</p>
<ul>
  <li>code </li>
  <li><a href="srs.html">software specification</a> and <a
 href="design.html">design</a> documents </li>
  <li>Quality report <br>
  </li>
</ul>
<p>
The Table <a
 href="file://localhost/Users/acary/Siconos/software/trunk/Docs/Dev/QP/QP/QP.html#Tab:IO-Products">2.2</a>
summarizes the software products of each phase as required by ESA
PSS-05-0. The timetable for the output deliverables will be given
in&nbsp; the part schedule.
<br>
</p>
<div align="center"><a name="411"></a>
<table>
  <caption><strong>Table 2.2:</strong>
Phase input and output products</caption> <tbody>
    <tr>
      <td>
      <div align="center">
      <table style="width: 651px; height: 246px;" border="1"
 cellpadding="3">
        <tbody>
          <tr>
            <td align="left" valign="top" width="181">Phase</td>
            <td align="left">Input product</td>
            <td align="left" valign="top" width="82">Output Product</td>
          </tr>
          <tr>
            <td
 style="width: 181px; vertical-align: top; text-align: left;">User
&amp;
Software Requirements (UR, SR)</td>
            <td style="text-align: left;">User requirements elicitation</td>
            <td
 style="width: 180px; vertical-align: top; text-align: left;"><a
 href="srs.html">Software requirements specification</a></td>
          </tr>
          <tr>
            <td
 style="width: 160px; vertical-align: top; text-align: left;">Architectural
Design (AD)</td>
            <td align="left"><a href="srs.html">Software requirements
specification</a></td>
            <td align="left" valign="top" width="82"><a
 href="design.html">design</a></td>
          </tr>
          <tr>
            <td align="left" valign="top" width="181">Detailed Design
(DD)</td>
            <td align="left"><a href="design.html">design</a></td>
            <td align="left" valign="top" width="82">code<br>
User Manual<br>
            </td>
          </tr>
          <tr>
            <td align="left" valign="top" width="181">Test and
Transfer(TR)</td>
            <td align="left"><a
 href="file:///Users/acary/Siconos/software/trunk/Docs/Dev/Kernel/qa-plan.html">Quality
assurance plan</a></td>
            <td align="left" valign="top" width="82">Quality report<br>
            </td>
          </tr>
          <tr>
            <td align="left" valign="top" width="181">Operations and
maintenance (OM)</td>
            <td align="left"><a href="srs.html">Software requirements
specification</a><br>
            <a href="qa-plan.html">Quality assurance plan</a><br>
            </td>
            <td align="left" valign="top" width="82">Project history
document</td>
          </tr>
        </tbody>
      </table>
      <a name="Tab:IO-Products"></a></div>
      </td>
    </tr>
  </tbody>
</table>
</div>
<br>
<p>Because the developing staff is small, and in order to maintain the
best consistency as possible in the documentation, the number of
project documents is reduced in regard to esa software engineering
guides recommendations :
</p>
<ul>
  <li>The users requirements and software requirements are joined in a
common document for all
modules of the platform, the <a href="srs.html">Software requirements
specification</a> document </li>
  <li>Every project management, quality process data, and testing plans
are joined in a common document <a href="qa-plan.html">Quality
Assurance plan</a></li>
  <li>Quality and
testing reports are both in the Quality report<br>
  </li>
</ul>
<h5><a name="SECTION00331300000000000000">Global life cycle</a></h5>
<p>
The incremental delivery approach, shown in Figure <a
 href="file://localhost/Users/acary/Siconos/software/trunk/Docs/Dev/QP/QP/QP.html#Fig:Icycle">2.1</a>,
is characterized by splitting the DD, TR and OM phases into a number of
more manageable units,
once the complete architectural design has been defined. The software
is delivered in multiple releases, each with increased functionality
and capability.
This may occurs when certain functions may need to be in place before
others can be effective.
<br>
</p>
<div align="center"><a name="Fig:Icycle"></a><a name="427"></a>
<table style="width: 621px; height: 391px;">
  <caption align="bottom"><strong>Figure 2.1:</strong>
Software life-cycle and input/output documents according to each phase
of development.</caption> <tbody>
    <tr>
      <td><img alt="Software Life-Cycle"
 src="figures/incremental_life_cycle.png"
 style="width: 606px; height: 344px;"><br>
      </td>
    </tr>
  </tbody>
</table>
</div>
<p>During each increment, software requirements and architectural
design documents are reviewed and may be lightly corrected. Detailed
design, user manual and testing plans are completed as the work
gradually progresses. <br>
</p>
<p>This life-cycle was chosen for this project because the kernel and
basic functionnalities of the platform have to be validated before the
development of specific plugins or of a smart interface. <br>
</p>
<h5><a name="SECTION00331400000000000000">First increment : platform
prototype</a></h5>
<p>
This prototype was realized by four students in computer sciences
during their final training course. From January to September 2004,
they realized a complete increment cycle and they considered this first
increment as a complete project development from user requirements
elicitation to acceptance tests. To reach this objective, they used a
standard software life-cycle approach illustrated on figure <a
 href="file://localhost/Users/acary/Siconos/software/trunk/Docs/Dev/QP/QP/QP.html#Fig:Vcycle">2.2</a>.
<br>
<a name="Fig:Vcycle"></a>
<br>
<a name="Fig:Icycle"></a><a name="427"></a>
</p>
<table
 style="text-align: left; margin-left: auto; margin-right: auto; width: 1234px; height: 587px;">
  <caption align="bottom"><strong>Figure 2.2:</strong>
Software life-cycle and input/output documents according to each phase
of development.</caption> <tbody align="center">
    <tr>
      <td><img alt="V-Cycle" src="figures/Vcycle.png"
 style="width: 1010px; height: 562px;"></td>
    </tr>
  </tbody>
</table>
<p><br>
<br>
</p>
<h3><a name="SECTION00331500000000000000"></a></h3>
<h4><a name="SECTION00332000000000000000">Methods and Models</a></h4>
<p>
</p>
<h5><a name="SECTION00332100000000000000">cocomo</a></h5>
<p>
This is a cost model for estimating the number of person-months
required to develop software. The model also estimates the development
schedule in months and produces an effort and schedule distribution by
major phases. This model is based on Barry Boehm's accocomo<a
 name="tex2html4"
 href="file://localhost/Users/acary/Siconos/software/trunk/Docs/Dev/QP/QP/QP.html#foot706"><sup>2.1</sup></a>.Here
is what Boehm says about the model: "Basic COCOMO is good for rough
order of magnitude estimates of software costs, but its accuracy is
necessarily limited because of its lack of factors to account for
differences in hardware constraints, personnel quality and experience,
use of modern tools and techniques, and other project attributes known
to have a significant influence on costs." For more detailed
information about cocomo and software cost estimating in general, I
strongly recommend reading Software Engineering Economics (1981), by
Barry Boehm.
</p>
<p>The model estimates cost using one of three different
development modes: organic, semidetached and embedded. Here is a
summary of how Boehm describes the modes:
</p>
<ul>
  <li>Organic : In the organic mode, relatively small software teams
develop software in a highly familiar, in-house environment. Most
people connected with the project have extensive experience in working
with related systems within the organization, and have a thorough
understanding of how the system under development will contribute to
the organizations objectives. Very few organic-mode projects have
developed products with more than 50 thousand delivered source
instructions (KDSI). . </li>
  <li>Semidetached: The semidetached mode of software development
represents an intermediate stage between the organic and embedded
modes. "Intermediate" may mean either of two things: an intermediate
level of project characteristic or a mixture of the organic and
embedded mode characteristics.The size range of a semidetached mode
product generally extends up to 300 KDSI. </li>
  <li>Embedded : The major distinguishing factor of an embedded-mode
software project is a need to operate within tight constraints. The
product must operate within (is embedded in) a strongly coupled complex
of hardware, software, regulations, and operational procedures, such as
an electronic funds transfer system or an air traffic control system. </li>
</ul>
<p>
</p>
<h5>
Design method SA/SD method and diagram<br>
</h5>
<p>
</p>
<h4>
</h4>
The sd method is an extension to the sa method. This method is based on
the analysis of the data flow to get a first level architecture. Then
this architecture is evaluated and restructured. This is performed in
the seven steps of the method&nbsp;:
<ol>
  <li>Fundamental diagram </li>
  <li>Refinement of the data flow diagram </li>
  <li>Determination of the kind of diagram </li>
  <li>Plan of the frontier </li>
  <li>First level architecture </li>
  <li>Systematic building of the architecture </li>
  <li>Evaluation and restructuring of the architecture </li>
</ol>
&lt;&gt;With this method, one can evaluate the cohesion and the links
between modules which is very important for the evolution of the
software.
This method will help us to determine the global architecture.
In that way we will be able to design an architecture which will be
progressive.
The architecture must have low links between the different modules and
have a high cohesion.<br>
The sd diagram is a data flow diagram. It represents the input and
output of informations. It also shows the functions, the data storages
and the data flows.
<h3><br>
</h3>
<h5>Models / UML methods and Diagram<br>
</h5>
To build a good architecture of the platform, we will use various
modeling languages and tools. According to the type of information, we
want to depict, the appropriate model to formally represent data,
functions, and behaviours of our system. Among them, we can cite the
following diagrams :<a name="SECTION00332310000000000000"><br>
</a>
The uml diagrams are numerous and can modelise lots of relations
of the platform to define an adapted architecture to this platform.
<ul>
  <li>uml diagrams. <br>
We will use uml tools to create uml diagrams. With uml, we can modelise
a big part of the architecture with the numerous uml diagrams we will
see further, and with ocl.
    <ul>
      <li>Sequence diagram <br>
This diagram shows the links of the different actions we can find in
the platform. It represents the interactions between the entities of
the system. </li>
      <li>State diagram <br>
This diagram aims to represent automatons as state graphs. It shows the
changes of state of an object or a module in response to the
interactions. </li>
      <li>Collaboration diagram <br>
This diagram shows the interactions between the objects (instances of
classes and actors). It allows to represent the context of an
interaction. </li>
      <li>Classes diagram <br>
These diagram are collections of classes which show the structure of a
model. We use several diagrams for complex models. </li>
    </ul>
    <p> </p>
  </li>
  <li>ocl <br>
ocl is a declarative language for describing rules that apply to UML
models developed at IBM and now part of the UML standard. <br>
A formal specification language extension to UML. The Object Constraint
Language is a precise text language that provides constraint and object
query expressions on an object-oriented model that cannot otherwise be
expressed by diagrammatic notation. <br>
OCL supplements UML by providing expressions that have neither the
ambiguities of natural language nor the inherent difficulty of using
complex mathematics. <br>
    <p> </p>
  </li>
</ul>
<p>
</p>
<h4><a name="SECTION00332400000000000000">Format, style and tools for
documentation and the coding standards</a></h4>
All formats, styles and tools for documentation, and the Coding
standards are defined in the <a
 href="file://localhost/Users/acary/Siconos/software/trunk/Docs/Dev/Kernel/qa-plan.html">Software
Developpment Methodology</a>
<span style="font-weight: bold;"></span><br>
<h3>Work Breakdown structure</h3>
<br>
<div class="todo">
TODO: List tasks that will be needed for this project. Keep dividing
tasks into subtasks until you feel that you have enough detail to
expose risks and make reasonable estimates in ideal engineering hours.
</div>
<p>
</p>
<h4><a name="SECTION00341010000000000000">1000 Software Project
Management</a>
</h4>
<ul>
  <li>1100 numerics Management </li>
  <li>1200 kernel Management </li>
  <li>1300 analysis Management </li>
  <li>1400 control Management </li>
  <li>1500 imse Management </li>
  <li>1600 Existing softwares and modeling environments review </li>
  <li>1700 Relation with other project (Geoplex, Hycon, DaVinci, ...) </li>
  <li>1800 Studying legal aspects and planning APP deposit </li>
</ul>
<p>
</p>
<h4><a name="SECTION00341020000000000000">2000 Siconos/Numerics
Software Production</a>
</h4>
<ul>
  <li>2100 Software Specification phase SSD (Software Requirement and
Architectural Design phase)
    <ul>
      <li>2110 First Increment Production
        <ul>
          <li>2111 Global requirements elicitation </li>
          <li>2112 Partitionning of the whole requirements into sets of
functionalities </li>
          <li>2113 Definition of the priority between sets and of those
indispensable </li>
          <li>2114 Definition of some ``minimal'' requirements for a
given set </li>
          <li>2115 Definition of storage method for matrices </li>
          <li>2116 ssd draft </li>
          <li>2117 ssd final version
            <ul>
              <li>2117.1 Global functionalities of the sets </li>
              <li>2117.2 Data input and output </li>
              <li>2117.3 Interface with C++ </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>2120 Second Increment Production
        <ul>
          <li>2121 Inclusion of new sets </li>
          <li>2122 SciLab Toolbox </li>
        </ul>
      </li>
      <li>2130 Third Increment Production
        <ul>
          <li>2131 Enhancement of included sets
            <ul>
              <li>2131.1 Adding some specific storage method for
matrices </li>
              <li>2131.2 Adding some specific functionalities </li>
              <li>2131.3 Tuning existing functionnalities for
computation performance. </li>
            </ul>
          </li>
          <li>2132 Interface with other langages (Fortran9x, Python,
...) </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>2200 Detailed Design phase
    <ul>
      <li>2210 First Increment Production
        <ul>
          <li>2211 dddnumerics for the first increment sets
            <ul>
              <li>2211.1 Data Storage descriptions </li>
              <li>2211.2 Detailled interface of functions </li>
              <li>2211.3 Linear Algebra pack </li>
              <li>2211.4 NSS pack </li>
            </ul>
            <p> </p>
          </li>
          <li>2212 Interface with C++ </li>
          <li>2213 Unit Testing
            <ul>
              <li>2213.1 Problem samples </li>
            </ul>
          </li>
          <li>2214 sumnumerics for the first increment sets </li>
        </ul>
      </li>
      <li>2220 Second Increment Production
        <ul>
          <li>2221 Inclusion of new sets: ode pack, root finding </li>
          <li>2222 SciLab Toolbox </li>
        </ul>
      </li>
      <li>2230 Third Increment Production
        <ul>
          <li>2231 Sparse storage method for matrices </li>
          <li>2232 Linear Algebra pack for sparse matrices </li>
          <li>2233 Integration of ATLAS </li>
          <li>2234 Block Sparse storage method for matrices </li>
          <li>2235 NSS pack for block sparse matrices </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>2300 Transfer phase Acceptance testing
    <ul>
      <li>2310 First Increment Acceptance testing
        <ul>
          <li>2311 Acceptance test suite </li>
        </ul>
      </li>
      <li>2320 Second Increment Acceptance testing </li>
      <li>2330 Third Increment Acceptance testing </li>
    </ul>
  </li>
</ul>
<h4><a name="SECTION00341030000000000000">
3000 Platform kernel&nbsp;: Siconos/Engine Siconos/Front-End Software
Production</a>
</h4>
<ul>
  <li>3100 Software Requirements phase
    <ul>
      <li>3110 First Increment Production
        <ul>
          <li>3111 Requirements elicitation </li>
          <li>3112 Prototyping and Logical Model </li>
          <li>3113 srd draft </li>
          <li>3114 srd final </li>
        </ul>
      </li>
      <li>3120 Second Increment Production
        <ul>
          <li>3121 Update srd according to academical users feedback </li>
        </ul>
      </li>
      <li>3130 Third Increment Production
        <ul>
          <li>3131 Update srd according to industrial users feedback </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>3200 External Specification phase
    <ul>
      <li>3210 First Increment Production
        <ul>
          <li>3211 Describing software using context </li>
          <li>3212 Specifying Interfaces </li>
          <li>3213 Input/Output data description </li>
          <li>3214 Error Cases </li>
        </ul>
      </li>
      <li>3220 Second Increment Production
        <ul>
          <li>3221 Precising using context and the categories of users.
          </li>
          <li>3222 Definition and Specification of user interfaces, and
tools for their implementation
            <ul>
              <li>3222.1 End-user Interface : Scilab interface </li>
              <li>3222.2 Expert-user Interface : Python interface </li>
            </ul>
          </li>
          <li>3223 Precise definition for data input/output
            <ul>
              <li>3223.1 XML Input/Output </li>
              <li>3223.2 Expert-user Interface for data </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>3230 Third Increment Production (tbc) </li>
      <li>3231 Definition of error interface
        <ul>
          <li>3231.1 XML database for error messages </li>
          <li>3231.2 Internationalization (?) </li>
        </ul>
        <ul>
          <li>Linking with existing products </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>3300 Architectural Design phase
    <ul>
      <li>3310 First Increment Production
        <ul>
          <li>3311 Prototyping and Physical Model </li>
          <li>3312 add draft </li>
          <li>3313 add final
            <ul>
              <li>3313.1 SA/SD method application </li>
              <li>3313.2 Unit descriptions (conceptual class diagrams) </li>
              <li>3313.3 Simulation course (general sequence diagrams) </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>3320 Second Increment Production
        <ul>
          <li>3321 Design of user interfaces, and tools for their
implementation
            <ul>
              <li>3321.1 End-user Interface : Scilab interface </li>
              <li>3321.2 Expert-user Interface : Python interface </li>
            </ul>
          </li>
          <li>3322 Design for data input/output
            <ul>
              <li>3322.1 XML Input/Output </li>
              <li>3322.2 Expert-user Interface for data </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>3330 Third Increment Production (tbc)
        <ul>
          <li>3331 Design for data input/output
            <ul>
              <li>3331.1 End-user Interface for data </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>3400 Detailed Design phase
    <ul>
      <li>3410 First Increment Production
        <ul>
          <li>3411 ddd draft
            <ul>
              <li>3411.1 UML Class Diagram </li>
              <li>3411.2 I/O management : XML, "on the fly" nonsmooth
dynamical system creation </li>
              <li>3411.3 Software Deliverable Architecture </li>
            </ul>
          </li>
          <li>3412 First version of the code
            <ul>
              <li>3412.1 Model formalisation Unit </li>
              <li>3412.2 Model strategy Unit </li>
              <li>3412.3 XML I/O Unit </li>
              <li>3412.4 Front-end Unit </li>
              <li>3412.5 Numeric tools Unit </li>
            </ul>
          </li>
          <li>3413 Unit Testing
            <ul>
              <li>3413.1 CppUnit tests </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>3420 Second Increment Production
        <ul>
          <li>3421 Application Programing Interface
            <ul>
              <li>3421.2 Python interface </li>
              <li>3421.3 Scilab interface </li>
            </ul>
          </li>
          <li>3422 User Interface Unit
            <ul>
              <li>3421.1 Scilab interface </li>
              <li>3421.2 Python interface </li>
            </ul>
          </li>
          <li>3423 Model Formalisation Unit Production </li>
          <li>3424 Numerical Strategy Unit Production </li>
          <li>3425 LMGC90 Unit Production </li>
          <li>3426 XML schema 1.1 compliance </li>
        </ul>
      </li>
      <li>3430 Third Increment Production tbd </li>
    </ul>
  </li>
  <li>3500 Transfer phase
    <ul>
      <li>3510 automatic configuration (using Autoconf / Automake) </li>
      <li>3520 Portability
        <ul>
          <li>3521 Linux Platform (OS:Red Hat 9, Fedora Core2) </li>
          <li>3522 UNIX Platform (OS:Solaris) </li>
          <li>3523 Windows Platform (OS : Windows 2000/XP, Cygwin
environment) </li>
        </ul>
      </li>
      <li>3530 Software Transfer Documentation
        <ul>
          <li>3531 Completing Software User Manual </li>
          <li>3532 Installation documentation </li>
        </ul>
        <p> </p>
      </li>
    </ul>
  </li>
  <li>3600 Platform Testing
    <ul>
      <li>3610 First Increment Testing
        <ul>
          <li>3611 Templates systems and Benchmark definition </li>
          <li>3612 Integration and system testing </li>
          <li>3613 Acceptance Testing </li>
        </ul>
      </li>
      <li>3620 Second Increment Testing
        <ul>
          <li>3621 Templates systems and Benchmark definition </li>
          <li>3622 Integration testing </li>
          <li>3623 System Testing </li>
          <li>3624 Acceptance Testing </li>
        </ul>
      </li>
      <li>3630 Third Increment Testing
        <ul>
          <li>3631 Templates systems and Benchmark definition (model
plugin library) </li>
          <li>3632 Integration testing </li>
          <li>3633 System Testing </li>
          <li>3634 Acceptance Testing </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<h4><a name="SECTION00341040000000000000">
4000 Siconos/Analysis Software Production tbd</a>
</h4>
<ul>
  <li>4100 Software requirements phase SRD
    <ul>
      <li>4110 First Increment Production
        <ul>
          <li>4111 Requirements elicitation </li>
          <li>4112 Prototyping and Logical Model </li>
          <li>4113 Anaylys/SRD draft </li>
        </ul>
      </li>
      <li>4120 Second Increment Production
        <ul>
          <li>4121 Update Analysis/SRD according to academical users
feedback </li>
        </ul>
      </li>
      <li>4130 Third Increment Production
        <ul>
          <li>4131 Update Analysis/SRD according to industrial users
feedback </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>4200 External Specification phase
    <ul>
      <li>4210 First Increment Production
        <ul>
          <li>4211 Specify software using context </li>
          <li>4212 Specify interfaces </li>
          <li>4213 Input/Output data description </li>
          <li>4214 Error cases </li>
        </ul>
      </li>
      <li>4220 Second Increment Production </li>
      <li>4230 Third Increment Production </li>
    </ul>
  </li>
  <li>4300 Architectural Design phase ADD
    <ul>
      <li>4310 First Increment Production
        <ul>
          <li>4312 Prototyping and Physical Model </li>
          <li>4313 Analysis/ADD draft </li>
          <li>4314 Analysis/ADD final
            <ul>
              <li>4314.1 SA/SD method application </li>
              <li>4313.2 Unit descriptions </li>
              <li>4314.3 Simuation course </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>4320 Second Increment Production </li>
      <li>4330 Third Increment Production </li>
    </ul>
  </li>
  <li>4400 Detailed design phase
    <ul>
      <li>4410 First Increment Production
        <ul>
          <li>4411 First increments of the anlysis/ADD
            <ul>
              <li>4411.1 Brute-force Bifurcation diagrams </li>
              <li>4411.2 Domain of attraction calculations </li>
            </ul>
          </li>
          <li>4412 First version of the code </li>
        </ul>
      </li>
      <li>4420 Second Increment Production
        <ul>
          <li>4421 Addition to the Analysis/ADD
            <ul>
              <li>4421.1 Location of fixed points </li>
              <li>4421.2 Location of limit cycles </li>
              <li>4421.3 Continuation of fixed points </li>
              <li>4421.4 Continuation of limit cycles </li>
            </ul>
          </li>
          <li>4422 Updated version of the code </li>
        </ul>
      </li>
      <li>4430 Third Increment Production
        <ul>
          <li>4431 Addition to the Analysis/DDD
            <ul>
              <li>4431.1 Location of standard bifurcations of limit
cycles </li>
              <li>4431.2 Location of nonsmooth bifurcations of limit
cycles </li>
              <li>4431.3 Continuation of standard bifurcations of limit
cycles </li>
              <li>4431.4 Continuation of nonsmooth bifurcations of
limit cycles </li>
            </ul>
          </li>
          <li>4432 Updated version of the code </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>4500 Unit testing
    <ul>
      <li>4510 First Increment Testing
        <ul>
          <li>4511 Template systems and benchmark definitions </li>
          <li>4512 Integration Testing </li>
          <li>4513 System Testing </li>
          <li>4514 Acceptance Testing </li>
        </ul>
      </li>
      <li>4520 Second Increment Testing
        <ul>
          <li>4521 Template systems and benchmark definitions </li>
          <li>4522 Integration Testing </li>
          <li>4523 System Testing </li>
          <li>4524 Acceptance Testing </li>
        </ul>
      </li>
      <li>4530 Third Increment Testing
        <ul>
          <li>4531 Template systems and benchmark definitions </li>
          <li>4532 Integration Testing </li>
          <li>4533 System Testing </li>
          <li>4534 Acceptance Testing </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>4600 Transfer phase Acceptance testing
    <ul>
      <li>4610 First Increment Testing </li>
      <li>4620 Second Increment Testing </li>
      <li>4630 Third Increment Testing </li>
    </ul>
  </li>
</ul>
<h4><a name="SECTION00341050000000000000">
5000 Siconos/Control Software Production tbd</a>
</h4>
<ul>
  <li>5100 Software Requirements phase SRD </li>
  <li>5200 Architectural Design phase ADD </li>
  <li>5300 Detailed Design phase </li>
  <li>5400 Unit testing </li>
  <li>5500 Transfer phase Acceptance testing </li>
</ul>
<p>
</p>
<h4><a name="SECTION00341060000000000000">6000 Siconos/Pre-Post
Software Production tbd</a>
</h4>
<ul>
  <li>6100 Software Requirements phase SRD </li>
  <li>6200 Architectural Design phase ADD </li>
  <li>6300 Detailed Design phase </li>
  <li>6400 Unit testing </li>
  <li>6500 Transfer phase Acceptance testing </li>
</ul>
<br>
<h3>Description of the major workpackage</h3>
<br>
<p>In the section above, six work package has been defined. This first
work package, ``<i>1000 Software Project Management</i>'' to the
general management of the project. The last three packages are not yet
defined in details.
</p>
<p>We will described, in the following section, the two major work
package which are ``<i>2000 Siconos/Numerics Software Production</i>''
and ``<i>3000 Platform kernel Siconos/Engine Siconos/Front-End Software
Production </i>''.
</p>
<h4><a name="SECTION00342100000000000000">2000 Siconos/Numerics
Software Production</a></h4>
<p>
According to the numbering convention of the functionalities in the
srd, the increments of software production must contain :
<i>
<dl compact="compact">
  <dt>2310</dt>
  <dd>First Increment Production <br>
Linear algebra pack : F.1.001; F.1.003.1; F.1.003.2; F.1.010.1; <br>
NSS Pack : F.1.011.1; F.1.011.2; F.1.011.3; F.1.011.4 <br>
C++ interface : F.1.020 </dd>
  <dt>2320</dt>
  <dd>Second Increment Production <br>
ODE Pack : F.1.012; F.1.013; F.1.014; <br>
SciLab interface : F.1.020 <br>
  </dd>
  <dt>2330</dt>
  <dd>Third Increment Production <br>
Linear algebra pack optimisation : F.1.002 <br>
Matrices storage methods : F.1.003.4 <br>
Root finding : F.1.013 <br>
Automatic, analytical and numerical differentiation : F.1.014 <br>
  </dd>
</dl>
</i></p>
<p>This work package is realized by the SICONOS/Numerics defined in the
Section <a
 href="file://localhost/Users/acary/Siconos/software/trunk/Docs/Dev/QP/QP/QP.html#Sec:QP-PMP-PO">2.2</a>.
Only S. Nineb, which is a PhD Student hired by the project will work
full time for 6 months on this development. With the other
participants, the total resources for this work package may be
estimated around 10 man.month. These resources are only sufficient for
the design and the development of the first increment. For others
increments, it must be planned to hire an other person. </p>
<h4><a name="SECTION00342200000000000000">3000 Platform kernel
Siconos/Engine Siconos/Front-End Software Production</a></h4>
<p>
According to the numbering convention of the functionalities in the
srd, the increments of software production must contain :
<i>
<dl compact="compact">
  <dt>3310</dt>
  <dd>First Increment Production <br>
API C++ : F.2.000-F.2.002; PER.00 <br>
XML storage files : F.2.200; F.2.301; F.2.302; F.2.304; DAT.00;
F.3.000; INT.00; INT.01; <br>
Basic Plug-in : F.2.042; <br>
Model Formalization : F.2.015; F.2.024; F.2.027; <br>
Numerical strategy : F.2.100; F.2.102-F.2.105; <br>
Output and Trace values : F.2.303; </dd>
  <dt>3320</dt>
  <dd>Second Increment Production <br>
API C : F.3.001; <br>
Interface between the API C and Scilab tbd <br>
Interface between the API C++ and Python tbd <br>
Model Formalization : F.3.001; <br>
Numerical strategy : F.2.101; <br>
LMGC90 Plug-in : F.2.045; </dd>
  <dt>3330</dt>
  <dd>Third Increment Production <br>
The rest of functionalities.tbd </dd>
</dl>
</i></p>
<p>This work package is the core of the platform. It is realized by
Fr&eacute;d&eacute;ric Dubois, Vincent Acary and two software engineers
who are hired
for 6 month. The total resources for this work package is around 36
man.month. This will be sufficient to carry out the first and the
second increments. To carry out the third increment, it is planned to
hire a software engineer for the year 2005.
</p>
<h3>Schedule and Milestones</h3>
The two following tables present the general planning of SICONOS/WP2.
<p></p>
<table
 style="text-align: left; margin-left: auto; margin-right: auto; width: 646px; height: 530px;"
 border="1" cellpadding="3">
  <caption align="bottom">Definition of Milestones<br>
  </caption><tbody>
    <tr>
      <td align="left">&nbsp;ID</td>
      <td style="text-align: left;">Desciption of the milestone</td>
      <td align="left">Schedule</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td align="left"><i>M1.a</i></td>
      <td align="left">-- numerics: srs draft and NSS pack</td>
      <td align="left">March 2004</td>
    </tr>
    <tr>
      <td align="left"> <i>M1.b</i></td>
      <td align="left">-- srs and design draft of the kernel<br>
      </td>
      <td align="left">&nbsp;</td>
    </tr>
    <tr>
      <td align="left"> <i>M2.a</i></td>
      <td align="left">-- First Increment of the kernel complete (code
and tests)<br>
      </td>
      <td align="left">June 2004</td>
    </tr>
    <tr>
      <td align="left"> <i>M2.b</i></td>
      <td align="left">-- Documentation and Quality reports</td>
      <td align="left">September 2004</td>
    </tr>
    <tr>
      <td align="left"> <i>M3.a</i></td>
      <td align="left">-- Numerics : first increment complete</td>
      <td align="left">&nbsp;</td>
    </tr>
    <tr>
      <td align="left"><br>
      </td>
      <td align="left">-- Kernel 1 : API C and C++</td>
      <td align="left">&nbsp;</td>
    </tr>
    <tr>
      <td align="left"><br>
      </td>
      <td align="left">-- Kernel 2 : Numerics integration, Numerical
and model formalisation</td>
      <td align="left">January 2005</td>
    </tr>
    <tr>
      <th align="left"><i>M3.b</i></th>
      <td align="left">-- Numerics : Second increment complete</td>
      <td align="left">&nbsp;</td>
    </tr>
    <tr>
      <td align="left"><br>
      </td>
      <td align="left">-- Kernel 1 : Python and Scilab interface,
portability</td>
      <td align="left">&nbsp;</td>
    </tr>
    <tr>
      <td align="left"><br>
      </td>
      <td align="left">-- Kernel 2 : coupling LMGC90 to the platform</td>
      <td align="left">&nbsp;</td>
    </tr>
    <tr>
      <td align="left"><br>
      </td>
      <td align="left">-- Kernel 3 : First Benchmarks and Demonstation
examples</td>
      <td align="left">March 2005</td>
    </tr>
    <tr>
      <td align="left"> <i>M4.a</i></td>
      <td align="left">-- Third Increment of kernel (model and
numerical formalization)</td>
      <td align="left">&nbsp;</td>
    </tr>
    <tr>
      <td align="left"><br>
      </td>
      <td align="left">-- Model Plugin Library (Benchmarks and
Demonstation examples)</td>
      <td align="left">&nbsp;</td>
    </tr>
    <tr>
      <td align="left"><br>
      </td>
      <td align="left">-- Analysis : Evaluation of the Kernel and
Numerics (T1)</td>
      <td align="left">June 2005</td>
    </tr>
    <tr>
      <td align="left"> <i>M4.b</i> </td>
      <td align="left">-- Numerics : Third increment complete</td>
      <td align="left">&nbsp;</td>
    </tr>
    <tr>
      <td align="left">&nbsp;</td>
      <td align="left">-- Kernel : First distribution version with
Scilab and Python Interfaces</td>
      <td align="left">&nbsp;</td>
    </tr>
    <tr>
      <td align="left">&nbsp;</td>
      <td align="left">-- Analysis : First development increment
complete (T2 &amp; T3)</td>
      <td align="left">September 2005</td>
    </tr>
    <tr>
      <td align="left"> <i>M4.c</i></td>
      <td align="left">-- Analysis : First validation increment
complete (E2 &amp; E3)</td>
      <td align="left">December 2005</td>
    </tr>
    <tr>
      <td align="left"> <i>M5</i></td>
      <td align="left">-- Analysis : Second development increment
complete (T4 &amp; T5)</td>
      <td align="left">&nbsp;</td>
    </tr>
    <tr>
      <td align="left">&nbsp;</td>
      <td align="left">-- Control : First increment complete tbc</td>
      <td align="left">March 2006</td>
    </tr>
    <tr>
      <td align="left"> <i>M6</i></td>
      <td align="left">-- Analysis : Second validation increment
complete (E4 &amp; E4 &amp; E6)</td>
      <td align="left">September 2006</td>
    </tr>
    <tr>
      <td align="left">&nbsp;</td>
      <td align="left">-- Implementation of the imse complete tbc</td>
      <td align="left">September 2006</td>
    </tr>
    <tr>
      <td align="left"> <a name="Tab:milestones"></a></td>
      <td align="left">&nbsp;</td>
      <td align="left">&nbsp;</td>
    </tr>
  </tbody>
</table>
<h3>Human resources assignment and budget<br>
</h3>
<br>
<div class="todo"> Recall the human resources and budget. How it has
been used actually ?
</div>
<br>
<h2>Configuration Management Plan</h2>
<h3>Introduction</h3>
<h3>Tool for configuration management : Subversion</h3>
We use <a href="subversion.tigris.org">subversion</a> as a revision
control system. Subverion is an <font size="-1">open-source revision
control system, which aims to be a compelling replacement for CVS.</font><br>
<p>The following rules have to be respected by all users of siconos SVN
server :
</p>
<ul>
  <li>Write&nbsp; logs in english </li>
  <li>Except very particular cases, commit only sources which
succesfully
compiles (and pass tests for the code). This rule is valid as much for
documents as source code. </li>
  <li>Correct possible conflicts before committing your work. </li>
  <li>Official documents of WP2 are stored on SVN server.</li>
</ul>
<h3>Documents</h3>
<br>
<p>The documents concerned by this section are official project
documents,
such as <a href="srs.html">Software requirements specification</a> and
<a href="design.html">design</a> documents. These documents are written
in english and the last
validated version must be downloadable on <a
 href="http://gforge.inria.fr/projects/siconos/">Siconos Gforge web
site</a> in a PDF format file. After each major update , a document
must be validated by a team
leader and its version number increased.
The current version of these document is available on SVN project
server.
To get more details about Documents writing process, see the <a
 href="file://localhost/Users/acary/Siconos/software/trunk/Docs/Dev/Kernel/qa-plan.html">Software
Development Methodology</a> document.
</p>
<br>
<h2>Verification and Validation Plan</h2>
<dl>
</dl>
<h3>Introduction and contents</h3>
<p>The Verification and Validation plan is divided into three phases :
</p>
<ol>
  <li><b>Unit testing Plan</b>: In the phase of unit tests, one verify
that the software subsystems and components work
correctly in isolation, and as specified in the detailed design (see
ddd). The set of unit tests are defined for each increment in the
Chapter&nbsp;<a
 href="file://localhost/Users/acary/Siconos/software/trunk/Docs/Dev/QP/QP/QP.html#Sec:QP-PRUT">5</a>.
  </li>
  <li><b>Integration testing plan</b>: In the phase of integration
tests, one verify that the major software components work correctly
with the rest of the system, and as specified in the architectural
design (see add). The set of integration tests are defined for each
increment in the Chapter&nbsp;<a
 href="file://localhost/Users/acary/Siconos/software/trunk/Docs/Dev/QP/QP/QP.html#Sec:QP-PRIT">6</a>.
    <p> </p>
  </li>
  <li><b>System and Acceptance testing plan</b>: In the phase
acceptance tests, one verify that the software system meets the user
requirements (see srd and esd). The set of acceptance tests are defined
for each increment in the Chapter&nbsp;<a
 href="file://localhost/Users/acary/Siconos/software/trunk/Docs/Dev/QP/QP/QP.html#Sec:QP-PRAT">7</a>.
  </li>
</ol>
<p>
These verification activities demonstrate compliance
specifications. This may be done by showing that the product:
performs as specified;
contains no defects that prevent it performing as specified.
</p>
<p>The results of the verification and validation plan will be found in
the qr.
</p>
<h3><a name="SECTION00520000000000000000">Organisation of the reviews
to meet the plan</a></h3>
Reviews and meeting are regularly organized to present the work done.
People concerned by these reviews are all the development team members
and also the persons in charge of the development team.
<br>
<p>
That's the group leader who manages reviews and decides the main goal
of the review.So call-conference are organised between the inria
(Grenoble) and the lmgc (Montpellier). Moreover, meetings are planned
in one or the other city.
<br>
</p>
<p>During these reviews, the accomplished work is presented and present
people must have read the new or modified documents.<br>
</p>
<h3>Unit testing plan
</h3>
<p>
</p>
<h4><a name="SECTION00610000000000000000">Unit test tools<br>
</a></h4>
The tool used to do the unit tests is CppUnit. It allows to make test
suites on each independant module which must be tested.
<h4><a name="SECTION00620000000000000000">Scope of the Unit test plan</a></h4>
The following module have been included into the unit test plan :
<ul>
  <li>Each components of the Siconos/Kernel</li>
  <li>Siconos/Numerics </li>
</ul>
For each tested module, the unitary tests have to be performed
successfully before validating changes in the software.
<h4><a name="SECTION00621000000000000000">Objectives</a></h4>
The aim of these tests is to ensure that all the functions of the
tested module are doing that they have to do and that they are doing
that in the right way. The tests must show that the behaviour of each
function is the one which was expected.
<br>
The Unitary tests ensures us of the correct functioning of low level
operations that will be used at higher level.
<h4><a name="SECTION00621100000000000000">Satisfaction criterion</a></h4>
The unitary tests have to ensure :
<ul>
  <li>The reliability (right behaviour of the tested functions) </li>
  <li>The robustness (exception management) </li>
</ul>
These criterion ensure us that basic functions behave as we
expect.
With CppUnit, each test suite ends with a summary of the passed and
failed tests. To validate the modifications of the source code, it is
required that no test failed.
<h4><a name="SECTION00622000000000000000">Description of some specific
unit tests</a></h4>
<p>
</p>
<h5><a name="SECTION00622100000000000000">SiconosMatrix and
SiconosVector unitary tests</a><br>
</h5>
<p>
</p>
<ol>
  <li>Constructors and destructors : <br>
    <p> </p>
  </li>
  <li>Comparison operator : <br>
    <p> </p>
  </li>
  <li>Reading and writing in files : <br>
A vector and a matrix are saved into a file, then they are read and
the read values must be equal to the origin values. Binary and ASCII
storages are tested. </li>
  <li>Add function : <br>
    <p> </p>
  </li>
  <li>Affectation operator : <br>
    <p> </p>
  </li>
  <li>"linear solve" function : <br>
    <p> </p>
  </li>
  <li>Getter and Setter : <br>
    <p> </p>
  </li>
  <li>Computation operators ( +, -, *, /, ) : <br>
    <p> </p>
  </li>
  <li>blockMatrixCopy : <br>
The block matrix must be well copied into the current matrix,
wherever it is copied. Exception are rose when the copy would have been
overflow. </li>
  <li>Exceptions : <br>
  </li>
</ol>
<p>
</p>
<h5><a name="SECTION00622200000000000000">XML module unitary tests</a></h5>
<ol>
  <li>Get methods : <br>
They are the basics operations of the module. For each class of the
XML management module, getter functions must be able to read data from
an xml DOM tree. The reading of an XML file give us the way to tests
getters and setters. </li>
  <li>Access to inherited objects : <br>
The structure of the XML management module uses inheritance and
polymorphism. The use of generic classes to store information must
allow to grant the access to specific class attributes. Tests are
trying to call specific methods of generic pointer using static
casting, and polymorphism is tested by calling methods that are not
implemented in parent class but only in child class. </li>
  <li>Exception management : <br>
Bad manipulations of data structures have to launch exceptions. Each
exception which could be launched has to be tested. </li>
  <li>XML toolbox (SiconosDOMTreeTools) : <br>
Basic XML operations are managed with the SiconosDOMTreeTools
"toolbox". Access to the DOM tree containing XML data read from an XML
file is given with SiconosDOMTreeTools functions. These low level
methods are very important for all the XML management module. Tests
consists in manipulating the data of the DOM tree. So test suites are
reading/writing in the DOM tree with getter and setter functions. Also
the modification, add of new nodes and attributes with specific method
are tested, and a tool function which transforms a string into a vector
of double numbers. Alle these functions have to be tested unitarily. </li>
</ol>
<p>
</p>
<h5><a name="SECTION00622300000000000000">Siconos/Numerics</a></h5>
The different solving methods are tested with at least two problems.
<br>
<br>
<p>
<a name="Tab:NumericsTests"></a><br>
</p>
<h3>Integration testing plan<a name="SECTION00710000000000000000"><br>
</a></h3>
<h1>
</h1>
<p>
</p>
<h4><a name="SECTION00711000000000000000">Introduction</a></h4>
At first, we must know the software is a scientific computation
platform. It's compouned of two main parts. The first part is made of a
formalization module and a solving strategy one. This part is the
intelligence of the software. In front of that, the second part which
manage XML data, has the same structure that the first part.
<br>
The selected integration strategy is a progressive integration by
subsystem, where the subsystems were these defined during the
conception. The first subsystems are the formalization and the solving
strategy modules of the platform. Then all the XML management
module has been integrated to the growing platform. The plugins were
added once the platform was built.
<p>This document aims to present the tests done to validate the
integration of the platform. The modules concerned are the
formalization,
the solving strategy and the XML management.
<br>
This plan will highlight the communications between the various
modules, to check the good unfolding of the communications.
<br>
In this document you will find two main parts :
</p>
<ul>
  <li>a File part, which defines the development strategy used and the
satisfaction criteria. </li>
  <li>a Result part, which explain the results of the tests and analyze
them. </li>
</ul>
<p>
<br>
<br>
</p>
<h4><a name="SECTION00712000000000000000">Tests file</a></h4>
These integration tests are done during the development of each
module within the assigned time. They began when the API was complete
and
when the development was enough advanced.
<ul style="font-weight: bold;">
  <li><a name="SECTION00712200000000000000">Testing strategy</a></li>
</ul>
The tests are built to check all the links between modules and that the
communications are well done.<br>
<ul style="font-weight: bold;">
  <li><a name="SECTION00712300000000000000">Satisfaction criterions</a></li>
</ul>
<p>
</p>
The tests are validated by the person in charge for
the tests and for quality.
They must clearly show that the communication between modules are
established, and the good and complete unfolding of all the tests.
The test suite must test all the ways of communication between the
modules. The XML test file is complete and exhaustive for all the
objects the platform manages.
<ul>
  <li><a name="SECTION00712400000000000000"><span
 style="font-weight: bold;">Development of the tests</span></a></li>
</ul>
<ul>
  <ul>
    <li>&lt;&gt;<a name="SECTION00712410000000000000">Communication
tests
between strategy an the formalization</a>&lt;&gt;&lt;&gt;</li>
&lt;&gt;&lt;&gt;&lt;&gt;&nbsp;(Work breakdown structure.3611) <br>
  </ul>
</ul>
<div style="margin-left: 80px;">With this test, we verify that the
communications between each
OneStepIntegrator and his DynamicalSystem are well established, and
like
that each OneStepNSProblem is well associated with his Interactions.
This link is one-way, so we will check thatthe objects of the
solving strategy module can display the name of the formalization
module's object which is associated to it.
</div>
<ul style="margin-left: 40px;">
  <li><a name="SECTION00712420000000000000">Communication tests between
the XML management module and the remainder of the platform</a></li>
</ul>
<div style="margin-left: 80px;">(Work breakdown structure.3611.1,
3611.2, 3611.3)
<br>
In this test, we check that the reading of an XML inpt file will
create the link between the XML management module's objects and the
formalization and solving strategy modules' objects. Indeed, when an
XML input file is read, all the XML objects are created, and then,
the other object of the platform must be created.
<br>
The basement of the platform id the "Model" object type. It is a
Model that will launch the reading of the XML input file. When the XML
objects are created, the Model will begin to create and link the
formalization ad strategy objects to the XML objects.
<br>
We ensure oneself of the exactitude of the result by checking the
called functions during the unfolding of the test. All the methods
called will print to the screen their name in a log file, so it is easy
to see what happen. The resulting data of this test consists in a serie
of
method call that we can compare with the XML input data.
</div>
<ul style="margin-left: 40px;">
  <li><a name="SECTION00712430000000000000">Communication tests between
the plateform and the XML management module</a></li>
</ul>
<div style="margin-left: 80px;">(Work breakdown structure.3611.3)
<br>
In this test, we check that the communications between each object
of the platform are well done with the XML object associated to it.
<br>
In this way of communication, it correspond to the save of the platform
data to an XML file.
<br>
We ensure oneself of the exactitude of the result by checking the
method called in the log file. Moreover, the XML output file must be
similar to the input file because no computations have been made with
the data.
</div>
<ul style="margin-left: 40px;">
  <li><a name="SECTION00712440000000000000">Communication tests between
the platform and these plugins</a></li>
</ul>
<div style="margin-left: 80px;">(Work breakdown structure.3611.4)
<br>
This test must show tht the platform use the methods given with the
plugins.
<br>
To do that, we check the log file where the functions of the plugins
must have made specific outputs.<br>
</div>
<h3>System and Acceptance testing plan
</h3>
<br>
<h4><a name="SECTION00811000000000000000">Introduction</a>
</h4>
At first, we must know the software is a scientific computation
platform. It is composed of two main parts. The first part is made of a
formalization module and a solving strategy one. This part is the
intelligence of the software. In front of that, the second part which
manage XML data, has the same structure that the first part.
<br>
<p>
This document aims to present the tests done to validate the
functioning of the platform.
<br>
In this document you will find two main parts :
</p>
<ul>
  <li>a File part, which defines the development strategy used and the
satisfaction criterions. </li>
  <li>a Result part, which explain the results of the tests and analyze
them. </li>
</ul>
<p>
</p>
<h4><a name="SECTION00812000000000000000">Tests file</a></h4>
<p>
</p>
The acceptance tests have been realized during the development of
the plugin which allowed to simule the fall of a ball on a rigid plan.
It is a very simple example, but it allows to validate the stages order
of the simulation, the functioning of mechanisms for saving and
loading xml data as well as the plugins' mechanism of the platform.
<ul style="font-weight: bold;">
  <li><a name="SECTION00812200000000000000">Testing strategy</a></li>
</ul>
The test takes place in the following way : we read an input data
file; file written with the moad, then we do computations on the
desired number of steps. The results are validated by the moad.
<ul style="font-weight: bold;">
  <li><a name="SECTION00812300000000000000">Satisfaction criterions</a></li>
</ul>
The acceptance tests are validated by the person in charge for the
tests, for the quality and by the moad. The acceptance tests are
based on the requirements expressed by the customer in the srd.
<br>
The tests detailled in this document are based in the op, which is the
milestone until june 2004.
<ul style="font-weight: bold;">
  <li><a name="SECTION00812400000000000000">Development of the tests</a></li>
</ul>
<div style="margin-left: 80px;">(Work breakdown structure.3612)
<br>
</div>
<ul>
  <ul>
    <li><a name="SECTION00812410000000000000">XML input file</a></li>
  </ul>
</ul>
<div style="margin-left: 80px;">(Work breakdown structure.3611.1,
3611.2)
<br>
It consists in the description of 2 Lagrangian systems :a ball and a
rigid plan. They are represented as <i>Lagrangian Time Invariant
Dynamic Systems</i>.
<br>
This file is available in the appendices of this document.
</div>
<ul style="margin-left: 40px;">
  <li><a name="SECTION00812420000000000000">Ball simulation test</a></li>
</ul>
<div style="margin-left: 80px;">(Work breakdown structure.3612.1)
<br>
For this test, a plugin : BallPLugin.c, has been developped to
calculate specific functions of this problem (calculation of inertia,
of
the mass and external forces).
</div>
<p><br>
</p>
<dl>
  <dt> <br>
  </dt>
</dl>
<h2>Miscellaneous</h2>
<dl>
  <dt><br>
  </dt>
  <dt>Why is this QA plan needed?</dt>
  <dd>"Quality" refers to all the good things that we would like to see
in our product. We build a quality product and assure its quality by
keeping quality in mind all the time and performing the selected
activities below. Testing is one QA activity, but it is not the best or
only one, other QA activities include the use of style guides and
checklists, review meetings, use of analysis tools, and careful quality
measurements and estimates. A plan is needed to select and coordinate
all the QA activities.</dd>
</dl>
</div>
<div class="todo"><a title="pro use case template and sample test plan"
 href="http://www.readysetpro.com/">professional test plan template</a>.
</div>
</div>
<div class="legal1">Company Proprietary</div>
<div class="footnote"> Copyright &copy; 2003-2004 Jason Robbins. All
rights reserved. <a href="readyset-license.html">License terms</a>.
Retain this copyright statement whenever this file is used as a
template.
</div>
</div>
</body>
</html>
