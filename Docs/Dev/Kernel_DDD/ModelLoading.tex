

There are two major ways  to perform the loading of a model, i.e., to provide  the platform with data :
\begin{itemize}
\item Loading a XML data file containing the complete or a part of the model
\item Creating a complete or a part of a model through the various API in C++ or C
\end{itemize}
It might also possible to adopt a mixed strategy to load a model. 


\begin{ndr}
  In all of these case, the question of the validity of a model is  posed. 
What is the validation procedure ?
\end{ndr}

These functionnalities are based of the implementation of two adjoint trees of object classes :
\begin{itemize}
\item The first tree, \texttt{SiconosModel}  is the core of the modelingTools and simulationsTools.
\item The second class tree \texttt{siconosModelXML} is devoted the XML Management and interfaces the external  library which implements the API DOM (libxml2).
\end{itemize}
This choice has been justified by the independance with  the external library of the XML management and the ability to extend easily the I/O for new derived object types. It also avoid the overload of the Kernel source code. Moreover, Kernel objects are functionnal without any link to XML objects.

\begin{ndr}
  Improve the justification of the choice of implementation 
\end{ndr}

In this chapter, we describe the implementation and the technical choices for the management of the input user's data and the creation of the model with these information. Particularly, the following are (must be) defined :
\begin{itemize}
\item Creation of the objects inside the class tree SiconosModel
\item Loading of the SiconosModel objects from the minimal data input
\item Linking of the object with the father and the child in the class tree SiconosModel 
\item Linking and loading of the SiconosModel objects from the SiconosModelXML
\item Creation of the objects inside the class tree SiconosModelXML
\item Loading of the SiconosModel objects from the XML data file
\item Linking of the object with the father and the child in the class tree SiconosModelXML
\item Description of some mixed loading Strategy (recall of the \ac{esd} normally !!) \S \ref{Sec:LoadingStrategy}
\item Save strategy of the SiconosModel tree
\item Save strategy of the SiconosModelXML tree
\item Validation strategy of the SiconosModel tree
\item Validation strategy of the SiconosModelXML tree
\end{itemize}


This first  part of chapter which explains  the model loading form the user poiut of view  must be reported in the \ac{sum}. 

\section{Model Loading Strategy}
\label{Sec:LoadingStrategy}


\subsection{Model loading from an  XML data file}
The reading of the file generate a DOM tree in memory with all the data. After that,  the creation of the SiconosModelXML tree is  based on this DOM tree.  The SiconosModelXML belongs to the SiconosModel object, which is the main object of the platform. From the SiconosModel,  the creation process is launched to build  all of the model. From this point, the Model creates the NSDS, which one creates the dynamical systems, ... The building is "top down" and gradually, with the Model at the top of the platform. 





\subsection{Creating and loading model through the API}
It is also  possible to create the objects of the platform without an XML file by using the API of the platform. The methods given to the users allow the creation of each object of the platform thanks to the constructors of each objects.

\subsection{Mixed strategies}
\label{mixed strategies}
It is possible to create a simulation by loading an XML file and then to add new information in the Kernel.\\
However, the opposite is not recommanded (creating manually some objects, and then loading an XMl file, you would have several SiconosModel in memory).\\
So, by loading some data from an input file, the creation process will build the platform with these data. And then you can manipulate the loaded information and also add dynamical systems, interactions, ...

\section{Definition of three major types of construtors for the Siconosmodel objects.}
%% \subsection{The "create" methods}
%% The "create" functions have for goal to initialize the relating object. They fill its fields with XML data and link the objects belonging to it to their corresponding XML object, or, if the platform is manually built, only fill its fields with the data given in paramaters.


In this section, we define three majors types of constructors which must be defined and used in all classes of the platfrom for the creation of objects. In order to fix ideas, we consider a template objects of the form :

  \input{./code/SiconosObject.h.tex}
%% \begin{lstlisting}[frame=single,caption={Template objects}]
%% Class ObjectSiconos: BaseObjectSiconos
%% {
%% public :
%% ObjectSiconos();
%% ...

%% private :
%% // Built-in types attributes (int, char, float, ..)
%%    string type;
%%    AttType att;
%%    ...

%% // Objects members (Composition)
%%    CompositionObject compositionObject;
%%    ...

%% // Pointer on external objects
%%    ObjectSiconosXML *objectsiconosxml;
%%    ExternalObject *externalObject;
%%    ...
   
%% }
%% \end{lstlisting} 





\subsection{The Default Constructor}

The default constructor performs the following operations :
\input{./code/SiconosObjectDefaultConstructor.cpp.tex}




%% \begin{lstlisting}[frame=single,caption={Default Constructor}]
%% ObjectSiconos::ObjectSiconos() :
%%    // Call explicitely one constructors of the base Object
%%    BaseObjectSiconos(...);
%%    // Call explicitely one constructors of the members
%%    // Built-in types attributes
%%    type("OBJECT_TYPE"), att(defaultvalue),
%%    //Object members :
%%    compositionObject(newDefaultValueIfNeccesary), ...
%%    {
%%    Initialization of pointers on external objects
%%    this->objectsiconosXML = 0 ;  // ObjectXML pointer
%%    this->externalObject = 0;

%%    // Do we need to call the new operator ?
%%     externalObject = new ExternalObject();
%%    }
%% \end{lstlisting} 

\begin{ndr}
  \begin{enumerate}
  \item Remove init() method !!!! This is the role of the Default constructor.
  \item Do we need to use the new operator if the sizes of the object are not defined ? What is the interest to call the Default constructor with a new ?
  \end{enumerate}

\end{ndr}

\subsection{Constructor with the mininal data}

This constructor performs  the contruction of a object through given a minimal set of data that corresponds to required data for each created object.  It is composed of the following operations :
\input{./code/SiconosObjectOtherConstructor.cpp.tex}
%% \begin{lstlisting}[frame=single,caption={Constructor from the mininal data}]
%% Object::object(AttributeType1 data1,...,AttributeTypeN dataN )
%%    {
%%    Object(); // Default constructor

%%    // Loading of Simple type attributes
%%    this->attribute1 = data1 ; //loading of the attributes
%%    ....
%%    this->attributeN = dataN ;

%%    //Object attributes

%%    // if data are present for this object call the specific constructor
%%    attributeObject1 = new AttributeObject1type(data11, data 1N);

%%    // if not, do we need to call the default constructor (new needed ?)
%%    attributeObject1 = new AttributeObject1type();
%%    // XML Management, node creation, and link downwards ? see NDR below
%%    }
%% \end{lstlisting} 

 \begin{ndr}
   \begin{enumerate}
   \item Be careful of the conflict between the new in the Default Constructor and in this constructor, if a new is called in the default Constructor
   \item Define if the object in attributes must created now of after and then link
   \item Define the procedure for the XML management :
     \begin{itemize}
     \item  Where  is the constructor of the assciated ObjectXML ? 
     \item  Use of the SaveObjectXML ?
     \item  Creation of XML sub -tree ? Advantages : Don't need to know what is the father node to fullfill a node at the moment of construction
     \end{itemize}
   \end{enumerate}
 \end{ndr}


\subsection{Constructor with the ObjectXML of the SiconosModelXML tree}

This constructor performs  the contruction of a object given a XML node. There is two steps in this type of contruction  based on the two-associated objetcs, i.e, Object, ObjectXML (for instance, DynamicalSystem and DynamicalSystemXML). The first one is the loading of the ObjectXML from the XML node.This step will be detailed in the section \ref{Sec:XMLnode}. The second  step is the loading of the attributes of the object from the ObjectXML. The operations are described in the Listing~\ref{ConstructorObjectXML}.

\input{./code/SiconosObjectConstructorfromXML.cpp}
%% \begin{lstlisting}[frame=single,caption={Constructor from the ObjectXML of the SiconosModelXML tree }, label={ConstructorObjectXML}]
%% Object::Object(ObjectXML objectxml)
%%    {
%%     Object(); // Default constructor
%%     this->objectxml = objectXML;        
%%     this->fillObjectWithDSXML(); // Loading of the attribute from the ObjectXML
%%     this->linkObjectXML();       // Link downwards
%%    }
%% \end{lstlisting} 

\textbf{\textit{Remark :}} The SiconosModel owns the only constructor that needs a string corresponding to an XML file, instead of an XML object.\\
\textbf{\textit{Remark :}} About the DSInputOutput. In the XML file, they are defined a the same level than the dynamical system, whereas they are linked to these dynamical systems. This position is due to the fact one DSInputOutput can be used by several dynamical systems. So, during the loading of the NSDSXML,  DSIOXML objects have to be loaded before DSXML objects to be able to link the DSXML with there DSIOXML.\\



 \begin{ndr}
   \begin{enumerate}
   \item Define the procedure for the XML management of the child :
     \begin{itemize}
     \item The constructor for the Child Object (Externalobject) is in the link ?
     \end{itemize}
   \item Perhaps rename the method fill and link, or include it directly in the constructor ?
   \end{enumerate}
 \end{ndr}

\clearpage

%\input{SiconosObject.cpp.tex}





\subsection{On the use of the operator new and delete in the constructors and the destructors}


\begin{ndr}
  \begin{enumerate}
  \item Define a rule on the use  operator new and delete in the constructors and the destructors. For instance, 
    \begin{itemize}
    \item Should we delete objects in the destructor which have been created with a new in a Constructor ?
    \end{itemize}
  \item A question, which is also related, is  the use of a pointer rather than directly a object in the attributes of a Object. (Example in DynamicalSystem, difference between x and r ?)
  \end{enumerate}
\end{ndr}
\ac{tbd}
\clearpage


\section{Object Factories}

\subsection{Purpose}

\subsection{Implementation}

\clearpage



\label{Sec:DDD-XMLLoading}
\input{ModelLoadingfromXML}


\clearpage
 \section{Validation of data}
\subsection{XML schema validation}
When a XML file bring the data needed by the platform, either all the data are given by the XML file or only required data. When the file contains partial data, that means it describe at least a SiconosModel with a NSDS (Non Smooth Dynamical System), composed of at least one Dynamical System.

\subsection{Check member functions}



\clearpage
\section{Saving the data of the platform in a XML file}



The save of the platform's data is lead from the Model. The function which do this job is
"saveToXMLFile". It has several things to do before saving tha data in a XML file :
\begin{itemize}
        \item checkXMLPlatform() : This first function will perfom verifications on the XML Management platform. It checks the
        link between the platform's objects and the XML Management objects. If the XML Management
        platform doesn't exist, it will be created and linked to the objects of the \ac{siconos}
        platform. Otherwise, every link between the platform and the XML Management is checked to ensure
        the availability of the XML platform objects.
        \item savePlatformToXML() : Now, all the objects of the platform are linked to their XML Management object. Therefore,
        it is possible to save the data of the platform to the XML DOM tree. The information
        contained in the platform are saved in the DOM tree by using the specific functions given
        by the XML object.
        \item checkXMLDOMTree() : The data of the DOM tree is up to date. But It is important to check that these data still
        respect the XML schema. 
        \item saveSiconosModelInXMLFile(xmlFile) : The last action to be done is to write the data in memory to a file.
\end{itemize}
