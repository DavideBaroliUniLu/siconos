This chapter provides guidelines and rules for developpers to implement new classes. 

\section{Constructors}
For each object three (at least) constructors are defined: 
\begin{itemize}
\item default.\\
This constructor is declared as a private or protected member function, making it accessible only to base and derived classes functions. 
\item from an xml file:\\
  to perform  the contruction of an object given by an XML node. It consists in two steps based on the two-associated objetcs, i.e, Object and ObjectXML (for instance, DynamicalSystem and DynamicalSystemXML). The first one is a loading of the ObjectXML from the XML node.This step will be detailed in the section \ref{Sec:XMLnode}. The second  step is the loading of the attributes of the object from the ObjectXML. The operations are described in the Listing~\ref{ConstructorObjectXML}.
\textbf{\textit{Remark :}} The SiconosModel owns the only constructor that needs a string corresponding to an XML file, instead of an XML object.\\
\textbf{\textit{Remark :}} About the DSInputOutput. In the XML file, they are defined a the same level than the dynamical system, whereas they are linked to these dynamical systems. This position is due to the fact one DSInputOutput can be used by several dynamical systems. So, during the loading of the NSDSXML,  DSIOXML objects have to be loaded before DSXML objects to be able to link the DSXML with their DSIOXML.\\
 \begin{ndr}
   \begin{enumerate}
   \item Define the procedure for the XML management of the child :
     \begin{itemize}
     \item The constructor for the Child Object (Externalobject) is in the link ?
     \end{itemize}
   \item Perhaps rename the method fill and link, or include it directly in the constructor ?
   \end{enumerate}
 \end{ndr}
\item from a minimum set of data
\end{itemize}
Some rules ...\\
for base class: 
\begin{itemize}
\item all members should be initialized in the constructor, as much as possible in the constructor list (see example below) 
\item Set all the pointers to 0.
\item Memory allocation for all pointers only when the size is known
\end{itemize}
Example:\\
\input{./code/constructor_list.tex}
for derived class: 
\begin{itemize}
\item same rules as base class.
\item Explicit call in the constructor list to one of the base class constructors (not necessary the default one). 
\end{itemize}
\begin{ndr}
  Wouldn't it be usefull to explicitly define a copy constructor?
\end{ndr}


\section{Destructor}
For each class, a destructor is explicitly defined, as a virtual function when derived classes exist. This can be understood by reading the following lines (for more details see \cite{Eckel2000}, chapter 15 p665): 
\input{./code/virtual_destructor.tex}
In this destructor each pointer member should be deleted (if allocated with new in constructor) and set to 0. 
%\section{Pointer members}
\section{Functions members}
\begin{itemize}
\item According to \cite{Eckel2000} (see details in chapter 8 p351 and chapter 11 p451), the first choice when passing an argument is to pass by const reference:\\
reference $\Rightarrow$ avoid pass by value, which means copy of data by creation of a temporary variable (always const). \\
const $\Rightarrow$ input argument can be a const and particularly a return value of another function. \\
This should be clear by reading the following example extracted from  \cite{Eckel2000} p 352: 
\input{./code/example_ref1.tex}
\item Any member function that do not modify members should be declared as a const, this to allow const declaration for the class object. 
\end{itemize}

\section{Getters and setters}
Since object members are private data, getters and setters functions should be implemented. 
They should respect the following rules:
\begin{itemize}
\item be implemented as inline functions in the header file
\item name ended by ``Ptr'' when function handle pointers
\item respect previous remarks about function members 
\end{itemize}
For ``classical'' type (ie non pointer) object members we set two functions, one to get the value without any possibility
 to change it (ie const attribute) and the other to set the value. A third one may possibly be added, to return the adress of the member. \\
For pointer type members, four functions are implemented: 
\begin{itemize}
\item 2 to get/set the pointer
\item 2 to get/set the value of the pointed object
\end{itemize}
Finally, the corresponding header file looks like: \\
\input{./code/getter_and_setter.tex}
Some remarks: 
\begin{itemize}
\item the get function (a), return a const, that means it can not be an lvalue, and so we can not write
getObjectMemberB = ...
\item (a) and (b) are const, that ensure they do not modify data members.
\item input argument in (c) is const and so can not be modified. 
\item a call to (d) means that any change on objectMemberB implies change on newPtr. 
\item for (d) function, it is necessary to first delete the data member and then to reassign it, this to avoid a ``double'' new (one on newPtr and another on objectMemberB), leading to error when call to delete at the end. 
\end{itemize}


\section{Summary and reference file}
As an example, the preceding remarks are summarized in the following header and cpp files\\
Header file: \\
\input{./code/reference_file_h.tex}
cpp file: \\
\input{./code/reference_file_cpp.tex}


